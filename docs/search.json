[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSA",
    "section": "",
    "text": "Hello, I am Nachiket Patil.\nI have decided to take notes while learning DSA."
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Selection_Sort.html",
    "href": "DSA Notes/Basic Sorting/Selection_Sort.html",
    "title": "Selection Sort",
    "section": "",
    "text": "üìñ Theory\nFind the minimum element from the unsorted part of array and put it at the end of sorted part of array at the begining.\nSteps:\n\nStart from the first element (index 0).\nFind the minimum element in the unsorted part (from current index to end).\nSwap this minimum element with the element at the current index.\nMove to the next index and repeat until the array is sorted.\n\nTime Complexity:\n\nBest: O(n¬≤)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n‚úÖ Code (C++)\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Selection Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Selection_Sort.html#selection-sort",
    "href": "DSA Notes/Basic Sorting/Selection_Sort.html#selection-sort",
    "title": "DSA",
    "section": "",
    "text": "Find the minimum element from the unsorted part of array and put it at the end of sorted part of array at the begining.\nSteps:\n\nStart from the first element (index 0).\nFind the minimum element in the unsorted part (from current index to end).\nSwap this minimum element with the element at the current index.\nMove to the next index and repeat until the array is sorted.\n\nTime Complexity:\n\nBest: O(n¬≤)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Selection Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Quick_Sort.html",
    "href": "DSA Notes/Advanced Sorting/Quick_Sort.html",
    "title": "Quick Sort",
    "section": "",
    "text": "üìñ Theory\nQuick Sort is a divide and conquer sorting algorithm. It works by selecting a ‚Äúpivot‚Äù element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\nSteps:\n\nChoose a pivot element (commonly the last element).\nPartition the array so that all elements less than the pivot are on the left, and all elements greater than the pivot are on the right.\nRecursively apply the above steps to the subarrays on the left and right of the pivot.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n¬≤) (when the smallest or largest element is always chosen as the pivot)\n\nSpace Complexity: O(log n) (due to recursion stack)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\nApplications:\n\nUseful for finding the kth smallest/ largest element (Quickselect algorithm).\n\n\n\n\n‚úÖ Code (C++)\nint partition(vector&lt;int&gt;& arr, int s, int e) {\n  int pivot = s;\n  int count = 0;\n\n  // Count all the numbers which are less the pivot number\n  for (int i = s; i &lt; e + 1; i++) {\n    if (arr[i] &lt; arr[pivot]) {\n      count++;\n    }\n  }\n\n  pivot = s + count;\n  int i = s, j = e;\n\n  while (i &lt; pivot && j &gt; pivot) {\n    if (arr[i] &lt; arr[pivot]) {\n      i++;\n    }\n    else if (arr[j] &gt;= arr[pivot]) {\n      j--;\n    }\n    else {\n      swap(arr[i], arr[j]);\n      i++;\n      j--;\n    }\n  }\n\n  return pivot;\n}\n\nvoid quickSort(vector&lt;int&gt;& arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int p = partition(arr, s, e);\n\n  quickSort(arr, s, p - 1);\n  quickSort(arr, p + 1, e);\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Quick Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Quick_Sort.html#quick-sort",
    "href": "DSA Notes/Advanced Sorting/Quick_Sort.html#quick-sort",
    "title": "DSA",
    "section": "",
    "text": "Quick Sort is a divide and conquer sorting algorithm. It works by selecting a ‚Äúpivot‚Äù element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\nSteps:\n\nChoose a pivot element (commonly the last element).\nPartition the array so that all elements less than the pivot are on the left, and all elements greater than the pivot are on the right.\nRecursively apply the above steps to the subarrays on the left and right of the pivot.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n¬≤) (when the smallest or largest element is always chosen as the pivot)\n\nSpace Complexity: O(log n) (due to recursion stack)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n\nint partition(vector&lt;int&gt;& arr, int s, int e) {\n  int pivot = s;\n  int count = 0;\n\n  // Count all the numbers which are less the pivot number\n  for (int i = s; i &lt; e + 1; i++) {\n    if (arr[i] &lt; arr[pivot]) {\n      count++;\n    }\n  }\n\n  pivot = s + count;\n  int i = s, j = e;\n\n  while (i &lt; pivot && j &gt; pivot) {\n    if (arr[i] &lt; arr[pivot]) {\n      i++;\n    }\n    else if (arr[j] &gt;= arr[pivot]) {\n      j--;\n    }\n    else {\n      swap(arr[i], arr[j]);\n      i++;\n      j--;\n    }\n  }\n}\n\nvoid quickSort(vector&lt;int&gt;& arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int p = partition(arr, s, e);\n\n  quickSort(arr, s, p - 1);\n  quickSort(arr, p + 1, e);\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Quick Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Merge_Sort.html",
    "href": "DSA Notes/Advanced Sorting/Merge_Sort.html",
    "title": "Merge Sort",
    "section": "",
    "text": "üìñ Theory\nMerge Sort is a divide and conquer algorithm. It divides the array into two halves, sorts each half recursively, and then merges the two sorted halves.\nSteps:\n\nDivide the array in two halves (like binary).\nRecursively sort both halves.\nMerge both sorted halves into a single sorted array.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n log n)\n\nSpace Complexity: O(n) (extra space for merging)\nStable: ‚úÖ Yes\nIn-place: ‚ùå No\n\nApplications:\n\nUsed in algorithm that count the number of inversions in array.\n\n\nExtra Things to Know:\n\nMerge Sort is often preferred for sorting linked lists because it does not require random access and can be implemented with O(1) extra space for linked lists.\n\n\n\n\n‚úÖ Code (C++)\nvoid mergeSort(vector &lt;int&gt; &arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int mid = s + (e - s) / 2;\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n\n  merge(arr, s, e);\n}\n\nvoid merge(vector &lt;int&gt; &arr, int s, int e) {\n  int mid = s + (e - s) / 2;\n  int len1 = mid - s + 1;\n  int len2 = e - mid;\n\n  int *first = new int[len1];\n  int *second = new int[len2];\n\n  int main_arr_ind = s;\n  for (int i = 0; i &lt; len1; i++) {\n    first[i] = arr[main_arr_ind++];\n  }\n\n  main_arr_ind = mid + 1;\n  for (int i = 0; i &lt; len2; i++) {\n    second[i] = arr[main_arr_ind++];\n  }\n\n  int ind1 = 0, ind2 = 0;\n  main_arr_ind = s;\n\n  while (ind1 &lt; len1 && ind2 &lt; len2) {\n    if (first[ind1] &lt; second[ind2]) {\n      arr[main_arr_ind++] = first[ind1++];\n    }\n    else {\n      arr[main_arr_ind++] = second[ind2++];\n    }\n  }\n\n  while (ind1 &lt; len1) {\n    arr[main_arr_ind++] = first[ind1++];\n  }\n\n  while (ind2 &lt; len2) {\n    arr[main_arr_ind++] = second[ind2++];\n  }\n\n  delete []first;\n  delete []second;\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Merge Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Merge_Sort.html#merge-sort",
    "href": "DSA Notes/Advanced Sorting/Merge_Sort.html#merge-sort",
    "title": "DSA",
    "section": "",
    "text": "Merge Sort is a divide and conquer algorithm. It divides the array into two halves, sorts each half recursively, and then merges the two sorted halves.\nSteps:\n\nDivide the array in two halves (like binary).\nRecursively sort both halves.\nMerge both sorted halves into a single sorted array.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n log n)\n\nSpace Complexity: O(n) (extra space for merging)\nStable: ‚úÖ Yes\nIn-place: ‚ùå No\n\n\n\n\nvoid mergeSort(vector &lt;int&gt; &arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int mid = s + (e - s) / 2;\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n\n  merge(arr, s, e);\n}\n\nvoid merge(&lt;vector&gt; &arr, int s, int e) {\n  int mid = s + (e - s) / 2;\n  int len1 = mid - s + 1;\n  int len2 = e - mid;\n\n  int *first = new int[len1];\n  int *second = new int[len2];\n\n  int main_arr_ind = s;\n  for (int i = 0; i &lt; len1; i++) {\n    first[i] = arr[main_arr_ind++];\n  }\n\n  main_arr_ind = mid + 1;\n  for (int i = 0; i &lt; len2; i++) {\n    second[i] = arr[main_arr_ind++];\n  }\n\n  int ind1 = 0, ind2 = 0;\n  main_arr_ind = s;\n\n  while (ind1 &lt; len1 && ind2 &lt; len2) {\n    if (arr[ind1] &lt; arr[ind2]) {\n      arr[main_arr_ind++] = arr[ind1++];\n    }\n    else {\n      arr[main_arr_ind++] = arr[ind2++];\n    }\n  }\n\n  while (ind1 &lt; len1) {\n    arr[main_arr_ind++] = arr[ind1++];\n  }\n\n  while (ind2 &lt; len2) {\n    arr[main_arr_ind++] = arr[ind2++];\n  }\n\n  delete []first;\n  delete []second;\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Merge Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Bubble_Sort.html",
    "href": "DSA Notes/Basic Sorting/Bubble_Sort.html",
    "title": "Bubble Sort",
    "section": "",
    "text": "üìñ Theory\nCompare adjacent elements, and move the large element to right in each loop.\n\nSteps:\n\nStart from the first element.\nCompare each pair of adjacent elements.\nIf the left element is greater than the right, swap them.\nRepeat for all elements, reducing the range by one each time (since the last element is sorted after each pass).\nStop if no swaps are made in a pass (array is sorted).\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n‚úÖ Code (C++)\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i &lt; n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;  // Optimization\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Bubble Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Bubble_Sort.html#bubble-sort",
    "href": "DSA Notes/Basic Sorting/Bubble_Sort.html#bubble-sort",
    "title": "DSA",
    "section": "",
    "text": "Compare adjacent elements, and move the large element to right in each loop.\n\nSteps:\n\nStart from the first element.\nCompare each pair of adjacent elements.\nIf the left element is greater than the right, swap them.\nRepeat for all elements, reducing the range by one each time (since the last element is sorted after each pass).\nStop if no swaps are made in a pass (array is sorted).\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i &lt; n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;  // Optimization\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Bubble Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Insertion_Sort.html",
    "href": "DSA Notes/Basic Sorting/Insertion_Sort.html",
    "title": "Insertion Sort",
    "section": "",
    "text": "üìñ Theory\nTake the first element from unsorted part, and put it at its correct position in sorted part.\n\nSteps:\n\nStart from the second element (index 1).\nCompare it with elements before it.\nShift larger elements one position to the right.\nInsert the current element into the correct position.\nRepeat for all elements.\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n‚úÖ Code (C++)\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        // Move elements greater than key to one position ahead\n        while (j &gt;= 0 && arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Insertion Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Insertion_Sort.html#insertion-sort",
    "href": "DSA Notes/Basic Sorting/Insertion_Sort.html#insertion-sort",
    "title": "DSA",
    "section": "",
    "text": "Take the first element from unsorted part, and put it at its correct position in sorted part.\n\nSteps:\n\nStart from the second element (index 1).\nCompare it with elements before it.\nShift larger elements one position to the right.\nInsert the current element into the correct position.\nRepeat for all elements.\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        // Move elements greater than key to one position ahead\n        while (j &gt;= 0 && arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Insertion Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Binary_Search.html",
    "href": "DSA Notes/Binary_Search.html",
    "title": "Binary Search",
    "section": "",
    "text": "üìñ Theory\nBinary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\n\n\n‚úÖ Code (C++)\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n    }\n    return -1; // Not found\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary_Search.html#binary-search",
    "href": "DSA Notes/Binary_Search.html#binary-search",
    "title": "DSA",
    "section": "",
    "text": "Binary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\n\n\n\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n    }\n    return -1; // Not found\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/Binary_Search.html",
    "href": "DSA Notes/Binary Search/Binary_Search.html",
    "title": "Binary Search",
    "section": "",
    "text": "üìñ Theory\nBinary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\nApplications:\n\nUsed in searching in sorted arrays.\nLower/upper bound problems.\nFinding insert position in sorted data.\n\n\nExtra Things to Know:\n\nSome times we face issue of index out of range. In such cases try taking s = 1 and e = n - 2. And ensure conditions on 0 and n - 1 before applying the while loop.\n\n\n\n\n‚úÖ Code (C++)\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return -1; // Not found\n}\nRecursive Verison\nint binarySearchRecursive(const vector&lt;int&gt;& arr, int s, int e, int target) {\n    if (s &gt; e) {\n        return -1;\n    }\n    int mid = s + (e - s) / 2;\n    if (arr[mid] == target) {\n        return mid;\n    }\n    else if (arr[mid] &lt; target) {\n        return binarySearchRecursive(arr, mid + 1, e, target);\n    }\n    else {\n        return binarySearchRecursive(arr, s, mid - 1, target);\n    }\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/BS_rotated_no_dupli.html",
    "href": "DSA Notes/Binary Search/BS_rotated_no_dupli.html",
    "title": "Binary Search in Rotated Sorted Array (No Duplicates)",
    "section": "",
    "text": "üìñ Theory\nThe array will be like {5, 6, 7, 8, 1, 2, 3}, here we have to find target element with the help of Binary Search.\n\nSteps:\n\nTo find the pivot index (index of the smallest element), set s = 0, e = n - 1.\nWhile s &lt; e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] &gt;= arr[0], set s = mid + 1.\nElse set e = mid.\n\nAfter the loop, s will be the index of the smallest element (pivot).\nCompare the target element with arr[0]:\n\nIf target &gt;= arr[0], apply binary search on the range [0, pivot - 1].\nElse, apply binary search on the range [pivot, n - 1].\n\n\n\n\n\n‚úÖ Code (C++)\nint pivot(vector &lt;int&gt; &arr) {\n    int s = 0, e = arr.size() - 1;\n\n    // Non rotated sorted array\n    if (arr[s] &lt;= arr[e]) {\n        return 0;\n    }\n\n    int mid = s + (e - s) / 2;\n    while (s &lt; e) {\n        if (arr[mid] &gt;= arr[0]) {\n            s = mid + 1;\n        }\n        else {\n            e = mid;\n        }\n        mid = s + (e - s) / 2;\n    }\n\n    return s;\n}\n\n// Now apply Binary Search",
    "crumbs": [
      "Home",
      "Binary Search",
      "BS in Rotated Array (No Duplicates)"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/BS_rotated_dupli.html",
    "href": "DSA Notes/Binary Search/BS_rotated_dupli.html",
    "title": "Binary Search in Rotated Sorted Array (With Duplicates)",
    "section": "",
    "text": "üìñ Theory\nThe array will be like {3, 3, 5, 6, 7, 8, 8, 8, 1, 2, 3}, here we have to find target element with the help of Binary Search.\n\nSteps:\n\nTo find the pivot index (index of the smallest element), set s = 0, e = n - 1.\nWhile s &lt; e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] &gt; arr[e], set s = mid + 1.\nElse if arr[mid] &lt; arr[e], set e = mid.\nElse (arr[mid] == arr[e]), decrement e by 1.\n\nAfter the loop, s will be the index of the smallest element (pivot).\nCompare the target element with arr[0]:\n\nIf target &gt;= arr[0], apply binary search on the range [0, pivot - 1].\nElse, apply binary search on the range [pivot, n - 1].\n\n\n\n\n\n‚úÖ Code (C++)\nint pivot(vector &lt;int&gt; &arr) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt; e) {\n        if (arr[mid] &gt; arr[e]) {\n            s = mid + 1;        \n        }\n        else if (arr[mid] &lt; arr[e]) {\n            e = mid;             \n        }\n        else {\n            e--;                  \n        }\n        mid = s + (e - s) / 2;\n    }\n\n    return s;\n}\n\n// Now apply Binary Search",
    "crumbs": [
      "Home",
      "Binary Search",
      "BS in Rotated Array (Duplicates)"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html",
    "href": "DSA Notes/Recursion/recursion.html",
    "title": "Recursion",
    "section": "",
    "text": "üìñ Theory\nRecursion is a programming technique where a function calls itself to solve smaller instances of a problem.\n\nWhy Use Recursion?\n\nSimplifies code for problems that have a natural recursive structure (e.g., trees, graphs, divide & conquer).\nMakes code easier to read for certain problems.\n\n\nKey Concepts\n\nBase Case: The condition under which the recursion ends. Prevents infinite recursion.\nProcessing: Where you perform some opeartions before next recursive call.\nRecursive Case: The part where the function calls itself with a smaller or simpler input.\n\n\nAnatomy of a Recursive Function\nvoid recursiveFunction(parameters) {\n    if (base_case_condition) {\n        // Handle base case\n        return;\n    }\n\n    // Processing\n\n    // Recursive call(s)\n    recursiveFunction(smaller_problem);\n}\n\nExample 1: Factorial\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}\nExample 2: Fibonacci Numbers\nint fibonacci(int n) {\n    if (n &lt;= 1) return n; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}\n\nHow Recursion Works (Call Stack)\n\nEach recursive call adds a new frame to the call stack.\nWhen a base case is reached, the stack unwinds.\n\nCommon Mistakes\n\nMissing base case: Leads to infinite recursion (stack overflow).\nIncorrect base case: May cause wrong results.\nNot reducing the problem: The recursive call must progress toward the base case.\n\nWhen to Use Recursion\n\nProblems that can be broken into similar subproblems (e.g., tree traversals, searching, sorting).\nWhen iterative solutions are complex or less readable.\n\n\nAdvanced Recursion\n\nBacktracking: Used for problems like permutations, combinations, N-Queens, Sudoku.\nDivide and Conquer: Algorithms like Merge Sort, Quick Sort use recursion to divide the problem.\nDynamic Programming (Memoization): Optimize recursive solutions by storing results of subproblems.\n\n\nExample: Backtracking (N-Queens)\nvoid solveNQueens(int row, vector&lt;string&gt;& board, vector&lt;vector&lt;string&gt;&gt;& solutions) {\n    if (row == board.size()) {\n        solutions.push_back(board);\n        return;\n    }\n    for (int col = 0; col &lt; board.size(); col++) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueens(row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}\n\nTips to Master Recursion\n\nDraw the recursion tree for small inputs.\nTrace the call stack step by step.\nStart with the base case and build up.\n\n\nRecursion vs Iteration\n\n\n\nRecursion\nIteration\n\n\n\n\nElegant for some problems\nUsually more efficient\n\n\nUses call stack\nUses loop variables\n\n\nCan be less efficient\nOften faster and uses less memory"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#what-is-recursion",
    "href": "DSA Notes/Recursion/recursion.html#what-is-recursion",
    "title": "Recursion",
    "section": "",
    "text": "Recursion is a programming technique where a function calls itself to solve smaller instances of a problem."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#why-use-recursion",
    "href": "DSA Notes/Recursion/recursion.html#why-use-recursion",
    "title": "Recursion",
    "section": "Why Use Recursion?",
    "text": "Why Use Recursion?\n\nSimplifies code for problems that have a natural recursive structure (e.g., trees, graphs, divide & conquer).\nMakes code easier to read for certain problems."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#key-concepts",
    "href": "DSA Notes/Recursion/recursion.html#key-concepts",
    "title": "Recursion",
    "section": "Key Concepts",
    "text": "Key Concepts\n\n1. Base Case\nThe condition under which the recursion ends. Prevents infinite recursion.\n\n\n2. Recursive Case\nThe part where the function calls itself with a smaller or simpler input."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#anatomy-of-a-recursive-function",
    "href": "DSA Notes/Recursion/recursion.html#anatomy-of-a-recursive-function",
    "title": "Recursion",
    "section": "Anatomy of a Recursive Function",
    "text": "Anatomy of a Recursive Function\nvoid recursiveFunction(parameters) {\n    if (base_case_condition) {\n        // Handle base case\n        return;\n    }\n    // Recursive call(s)\n    recursiveFunction(smaller_problem);\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-1-factorial",
    "href": "DSA Notes/Recursion/recursion.html#example-1-factorial",
    "title": "Recursion",
    "section": "Example 1: Factorial",
    "text": "Example 1: Factorial\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-2-fibonacci-numbers",
    "href": "DSA Notes/Recursion/recursion.html#example-2-fibonacci-numbers",
    "title": "Recursion",
    "section": "Example 2: Fibonacci Numbers",
    "text": "Example 2: Fibonacci Numbers\nint fibonacci(int n) {\n    if (n &lt;= 1) return n; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#how-recursion-works-call-stack",
    "href": "DSA Notes/Recursion/recursion.html#how-recursion-works-call-stack",
    "title": "Recursion",
    "section": "How Recursion Works (Call Stack)",
    "text": "How Recursion Works (Call Stack)\n\nEach recursive call adds a new frame to the call stack.\nWhen a base case is reached, the stack unwinds."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#common-mistakes",
    "href": "DSA Notes/Recursion/recursion.html#common-mistakes",
    "title": "Recursion",
    "section": "Common Mistakes",
    "text": "Common Mistakes\n\nMissing base case: Leads to infinite recursion (stack overflow).\nIncorrect base case: May cause wrong results.\nNot reducing the problem: The recursive call must progress toward the base case."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#when-to-use-recursion",
    "href": "DSA Notes/Recursion/recursion.html#when-to-use-recursion",
    "title": "Recursion",
    "section": "When to Use Recursion",
    "text": "When to Use Recursion\n\nProblems that can be broken into similar subproblems (e.g., tree traversals, searching, sorting).\nWhen iterative solutions are complex or less readable."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#practice-problems",
    "href": "DSA Notes/Recursion/recursion.html#practice-problems",
    "title": "Recursion",
    "section": "Practice Problems",
    "text": "Practice Problems\n\nSum of Array: Write a recursive function to sum all elements of an array.\nReverse a String: Recursively reverse a string.\nPower Function: Compute a^b recursively.\nCheck Palindrome: Check if a string is a palindrome using recursion.\nTower of Hanoi: Classic recursion puzzle."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#advanced-recursion",
    "href": "DSA Notes/Recursion/recursion.html#advanced-recursion",
    "title": "Recursion",
    "section": "Advanced Recursion",
    "text": "Advanced Recursion\n\n1. Backtracking\nUsed for problems like permutations, combinations, N-Queens, Sudoku.\n\n\n2. Divide and Conquer\nAlgorithms like Merge Sort, Quick Sort use recursion to divide the problem.\n\n\n3. Dynamic Programming (Memoization)\nOptimize recursive solutions by storing results of subproblems."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-backtracking-n-queens",
    "href": "DSA Notes/Recursion/recursion.html#example-backtracking-n-queens",
    "title": "Recursion",
    "section": "Example: Backtracking (N-Queens)",
    "text": "Example: Backtracking (N-Queens)\nvoid solveNQueens(int row, vector&lt;string&gt;& board, vector&lt;vector&lt;string&gt;&gt;& solutions) {\n    if (row == board.size()) {\n        solutions.push_back(board);\n        return;\n    }\n    for (int col = 0; col &lt; board.size(); col++) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueens(row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#tips-to-master-recursion",
    "href": "DSA Notes/Recursion/recursion.html#tips-to-master-recursion",
    "title": "Recursion",
    "section": "Tips to Master Recursion",
    "text": "Tips to Master Recursion\n\nDraw the recursion tree for small inputs.\nTrace the call stack step by step.\nStart with the base case and build up.\nPractice! The more problems you solve, the better you‚Äôll understand recursion."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#recursion-vs-iteration",
    "href": "DSA Notes/Recursion/recursion.html#recursion-vs-iteration",
    "title": "Recursion",
    "section": "Recursion vs Iteration",
    "text": "Recursion vs Iteration\n\n\n\nRecursion\nIteration\n\n\n\n\nElegant for some problems\nUsually more efficient\n\n\nUses call stack\nUses loop variables\n\n\nCan be less efficient\nOften faster and uses less memory"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#summary",
    "href": "DSA Notes/Recursion/recursion.html#summary",
    "title": "Recursion",
    "section": "Summary",
    "text": "Summary\n\nRecursion is a powerful tool for solving complex problems.\nAlways define a clear base case.\nPractice with classic problems to build intuition."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#further-reading",
    "href": "DSA Notes/Recursion/recursion.html#further-reading",
    "title": "Recursion",
    "section": "Further Reading",
    "text": "Further Reading\n\nRecursion (GeeksforGeeks)\nVisualgo Recursion Visualizer\nLeetCode Recursion Problems"
  },
  {
    "objectID": "DSA Notes/Recursion/finding_power_set.html",
    "href": "DSA Notes/Recursion/finding_power_set.html",
    "title": "Finding the Power Set",
    "section": "",
    "text": "üìñ Theory\nYou will be given an array like {1, 2, 3} or a string \"abc\". You need to find out all possible subsets, e.g.: - For {1, 2, 3}: {[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]} - For \"abc\": {\"\", \"a\", \"ab\", \"abc\", \"ac\", \"b\", \"bc\", \"c\"}\n\nUsing Recursion\n\nAt each step, decide to include or exclude the current element.\nBase Case: If i &gt;= arr.size(), print or store the current subset.\n\n  Base Case:\n    i &gt;= arr.size();\n\n   i        output                            \n  {1, 2, 3} , {}\n   |                         i      output\n   |-- |-- include 1 --&gt; {1, 2, 3} , {1,}\n       |                     |                        i    output              \n       |                     |-- include 2 --&gt; {1, 2, 3} , {1, 2}\n       |                     |                        i    output\n       |                     |-- exclude 2 --&gt; {1, 2, 3} , {1,}\n       |\n       |                     i      output\n       |-- exclude 1 --&gt; {1, 2, 3} , {}\n       |                     |                        i    output              \n       |                     |-- include 2 --&gt; {1, 2, 3} , {2}\n       |                     |                        i    output\n       |                     |-- exclude 2 --&gt; {1, 2, 3} , {}\n\nLike wise include and exclude the next numbers recursively.",
    "crumbs": [
      "Home",
      "Recursion",
      "Finding the Power Set"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/pairing_two_or_multiple_sets.html",
    "href": "DSA Notes/Recursion/pairing_two_or_multiple_sets.html",
    "title": "Paring of Two or Multiple Arrays",
    "section": "",
    "text": "üìñ Theory\nWe will be given with [[a, b, c], [x, y, z]] and need to pair them in all possible ways as ax, ay, az, bx and so on.\n\nUsing Recursion\n\nAt each step (for each array), pick one element from the current array.\nMove to the next array and repeat the process, building up the current combination.\nBase Case: If you have picked one element from each array (i.e., reached the end), print or store the current combination.\nThis approach generates all possible pairings (or tuples) by exploring every choice at each level.\n\n  Base Case:\n    i &gt;= arr.size();\n\n  (   i   )             output\n  [a, b, c] & [x, y, z] , {}\n      |               (   i   )  output              (   i   )  output              (   i   )  output\n      |-- [a, b, c] & [x, y, z] , {a,} & [a, b, c] & [x, y, z] , {b,} & [a, b, c] & [x, y, z] , {c,}\n                          |\n                          |                       &lt; i output                       &lt; i output                       &lt; i output\n                          |-- [a, b, c] & [x, y, z] , {a, x} & [a, b, c] & [x, y, z] , {a, y} & [a, b, c] & [x, y, z] , {a, z}                                                                                               \n      \nLike wise bx, by, bz and cx, cy, cz.",
    "crumbs": [
      "Home",
      "Recursion",
      "Paring of Two or Multiple Arrays"
    ]
  }
]