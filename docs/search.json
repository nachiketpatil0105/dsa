[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSA",
    "section": "",
    "text": "Hello, I am Nachiket Patil.\nI have decided to take notes while learning DSA.\n\nASCII - 128 Characters\nA to Z = 65 to 90\na to z = 97 to 122\n0 to 9 = 48 to 57"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Selection_Sort.html",
    "href": "DSA Notes/Basic Sorting/Selection_Sort.html",
    "title": "Selection Sort",
    "section": "",
    "text": "üìñ Theory\nFind the minimum element from the unsorted part of array and put it at the end of sorted part of array at the begining.\nSteps:\n\nStart from the first element (index 0).\nFind the minimum element in the unsorted part (from current index to end).\nSwap this minimum element with the element at the current index.\nMove to the next index and repeat until the array is sorted.\n\nTime Complexity:\n\nBest: O(n¬≤)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n‚úÖ Code (C++)\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Selection Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Selection_Sort.html#selection-sort",
    "href": "DSA Notes/Basic Sorting/Selection_Sort.html#selection-sort",
    "title": "DSA",
    "section": "",
    "text": "Find the minimum element from the unsorted part of array and put it at the end of sorted part of array at the begining.\nSteps:\n\nStart from the first element (index 0).\nFind the minimum element in the unsorted part (from current index to end).\nSwap this minimum element with the element at the current index.\nMove to the next index and repeat until the array is sorted.\n\nTime Complexity:\n\nBest: O(n¬≤)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Selection Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Quick_Sort.html",
    "href": "DSA Notes/Advanced Sorting/Quick_Sort.html",
    "title": "Quick Sort",
    "section": "",
    "text": "üìñ Theory\nQuick Sort is a divide and conquer sorting algorithm. It works by selecting a ‚Äúpivot‚Äù element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\nSteps:\n\nChoose a pivot element (commonly the last element).\nPartition the array so that all elements less than the pivot are on the left, and all elements greater than the pivot are on the right.\nRecursively apply the above steps to the subarrays on the left and right of the pivot.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n¬≤) (when the smallest or largest element is always chosen as the pivot)\n\nSpace Complexity: O(log n) (due to recursion stack)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\nApplications:\n\nUseful for finding the kth smallest/ largest element (Quickselect algorithm).\n\n\n\n\n‚úÖ Code (C++)\nint partition(vector&lt;int&gt;& arr, int s, int e) {\n  int pivot = s;\n  int count = 0;\n\n  // Count all the numbers which are less the pivot number\n  for (int i = s; i &lt; e + 1; i++) {\n    if (arr[i] &lt; arr[pivot]) {\n      count++;\n    }\n  }\n\n  pivot = s + count;\n  int i = s, j = e;\n\n  while (i &lt; pivot && j &gt; pivot) {\n    if (arr[i] &lt; arr[pivot]) {\n      i++;\n    }\n    else if (arr[j] &gt;= arr[pivot]) {\n      j--;\n    }\n    else {\n      swap(arr[i], arr[j]);\n      i++;\n      j--;\n    }\n  }\n\n  return pivot;\n}\n\nvoid quickSort(vector&lt;int&gt;& arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int p = partition(arr, s, e);\n\n  quickSort(arr, s, p - 1);\n  quickSort(arr, p + 1, e);\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Quick Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Quick_Sort.html#quick-sort",
    "href": "DSA Notes/Advanced Sorting/Quick_Sort.html#quick-sort",
    "title": "DSA",
    "section": "",
    "text": "Quick Sort is a divide and conquer sorting algorithm. It works by selecting a ‚Äúpivot‚Äù element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\nSteps:\n\nChoose a pivot element (commonly the last element).\nPartition the array so that all elements less than the pivot are on the left, and all elements greater than the pivot are on the right.\nRecursively apply the above steps to the subarrays on the left and right of the pivot.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n¬≤) (when the smallest or largest element is always chosen as the pivot)\n\nSpace Complexity: O(log n) (due to recursion stack)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n\nint partition(vector&lt;int&gt;& arr, int s, int e) {\n  int pivot = s;\n  int count = 0;\n\n  // Count all the numbers which are less the pivot number\n  for (int i = s; i &lt; e + 1; i++) {\n    if (arr[i] &lt; arr[pivot]) {\n      count++;\n    }\n  }\n\n  pivot = s + count;\n  int i = s, j = e;\n\n  while (i &lt; pivot && j &gt; pivot) {\n    if (arr[i] &lt; arr[pivot]) {\n      i++;\n    }\n    else if (arr[j] &gt;= arr[pivot]) {\n      j--;\n    }\n    else {\n      swap(arr[i], arr[j]);\n      i++;\n      j--;\n    }\n  }\n}\n\nvoid quickSort(vector&lt;int&gt;& arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int p = partition(arr, s, e);\n\n  quickSort(arr, s, p - 1);\n  quickSort(arr, p + 1, e);\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Quick Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Merge_Sort.html",
    "href": "DSA Notes/Advanced Sorting/Merge_Sort.html",
    "title": "Merge Sort",
    "section": "",
    "text": "üìñ Theory\nMerge Sort is a divide and conquer algorithm. It divides the array into two halves, sorts each half recursively, and then merges the two sorted halves.\nSteps:\n\nDivide the array in two halves (like binary).\nRecursively sort both halves.\nMerge both sorted halves into a single sorted array.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n log n)\n\nSpace Complexity: O(n) (extra space for merging)\nStable: ‚úÖ Yes\nIn-place: ‚ùå No\n\nApplications:\n\nUsed in algorithm that count the number of inversions in array.\n\n\nExtra Things to Know:\n\nMerge Sort is often preferred for sorting linked lists because it does not require random access and can be implemented with O(1) extra space for linked lists.\n\n\n\n\n‚úÖ Code (C++)\nvoid mergeSort(vector &lt;int&gt; &arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int mid = s + (e - s) / 2;\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n\n  merge(arr, s, e);\n}\n\nvoid merge(vector &lt;int&gt; &arr, int s, int e) {\n  int mid = s + (e - s) / 2;\n  int len1 = mid - s + 1;\n  int len2 = e - mid;\n\n  int *first = new int[len1];\n  int *second = new int[len2];\n\n  int main_arr_ind = s;\n  for (int i = 0; i &lt; len1; i++) {\n    first[i] = arr[main_arr_ind++];\n  }\n\n  main_arr_ind = mid + 1;\n  for (int i = 0; i &lt; len2; i++) {\n    second[i] = arr[main_arr_ind++];\n  }\n\n  int ind1 = 0, ind2 = 0;\n  main_arr_ind = s;\n\n  while (ind1 &lt; len1 && ind2 &lt; len2) {\n    if (first[ind1] &lt; second[ind2]) {\n      arr[main_arr_ind++] = first[ind1++];\n    }\n    else {\n      arr[main_arr_ind++] = second[ind2++];\n    }\n  }\n\n  while (ind1 &lt; len1) {\n    arr[main_arr_ind++] = first[ind1++];\n  }\n\n  while (ind2 &lt; len2) {\n    arr[main_arr_ind++] = second[ind2++];\n  }\n\n  delete []first;\n  delete []second;\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Merge Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Merge_Sort.html#merge-sort",
    "href": "DSA Notes/Advanced Sorting/Merge_Sort.html#merge-sort",
    "title": "DSA",
    "section": "",
    "text": "Merge Sort is a divide and conquer algorithm. It divides the array into two halves, sorts each half recursively, and then merges the two sorted halves.\nSteps:\n\nDivide the array in two halves (like binary).\nRecursively sort both halves.\nMerge both sorted halves into a single sorted array.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n log n)\n\nSpace Complexity: O(n) (extra space for merging)\nStable: ‚úÖ Yes\nIn-place: ‚ùå No\n\n\n\n\nvoid mergeSort(vector &lt;int&gt; &arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int mid = s + (e - s) / 2;\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n\n  merge(arr, s, e);\n}\n\nvoid merge(&lt;vector&gt; &arr, int s, int e) {\n  int mid = s + (e - s) / 2;\n  int len1 = mid - s + 1;\n  int len2 = e - mid;\n\n  int *first = new int[len1];\n  int *second = new int[len2];\n\n  int main_arr_ind = s;\n  for (int i = 0; i &lt; len1; i++) {\n    first[i] = arr[main_arr_ind++];\n  }\n\n  main_arr_ind = mid + 1;\n  for (int i = 0; i &lt; len2; i++) {\n    second[i] = arr[main_arr_ind++];\n  }\n\n  int ind1 = 0, ind2 = 0;\n  main_arr_ind = s;\n\n  while (ind1 &lt; len1 && ind2 &lt; len2) {\n    if (arr[ind1] &lt; arr[ind2]) {\n      arr[main_arr_ind++] = arr[ind1++];\n    }\n    else {\n      arr[main_arr_ind++] = arr[ind2++];\n    }\n  }\n\n  while (ind1 &lt; len1) {\n    arr[main_arr_ind++] = arr[ind1++];\n  }\n\n  while (ind2 &lt; len2) {\n    arr[main_arr_ind++] = arr[ind2++];\n  }\n\n  delete []first;\n  delete []second;\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Merge Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Bubble_Sort.html",
    "href": "DSA Notes/Basic Sorting/Bubble_Sort.html",
    "title": "Bubble Sort",
    "section": "",
    "text": "üìñ Theory\nCompare adjacent elements, and move the large element to right in each loop.\n\nSteps:\n\nStart from the first element.\nCompare each pair of adjacent elements.\nIf the left element is greater than the right, swap them.\nRepeat for all elements, reducing the range by one each time (since the last element is sorted after each pass).\nStop if no swaps are made in a pass (array is sorted).\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n‚úÖ Code (C++)\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i &lt; n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;  // Optimization\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Bubble Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Bubble_Sort.html#bubble-sort",
    "href": "DSA Notes/Basic Sorting/Bubble_Sort.html#bubble-sort",
    "title": "DSA",
    "section": "",
    "text": "Compare adjacent elements, and move the large element to right in each loop.\n\nSteps:\n\nStart from the first element.\nCompare each pair of adjacent elements.\nIf the left element is greater than the right, swap them.\nRepeat for all elements, reducing the range by one each time (since the last element is sorted after each pass).\nStop if no swaps are made in a pass (array is sorted).\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i &lt; n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;  // Optimization\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Bubble Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Insertion_Sort.html",
    "href": "DSA Notes/Basic Sorting/Insertion_Sort.html",
    "title": "Insertion Sort",
    "section": "",
    "text": "üìñ Theory\nTake the first element from unsorted part, and put it at its correct position in sorted part.\n\nSteps:\n\nStart from the second element (index 1).\nCompare it with elements before it.\nShift larger elements one position to the right.\nInsert the current element into the correct position.\nRepeat for all elements.\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n‚úÖ Code (C++)\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        // Move elements greater than key to one position ahead\n        while (j &gt;= 0 && arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Insertion Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Insertion_Sort.html#insertion-sort",
    "href": "DSA Notes/Basic Sorting/Insertion_Sort.html#insertion-sort",
    "title": "DSA",
    "section": "",
    "text": "Take the first element from unsorted part, and put it at its correct position in sorted part.\n\nSteps:\n\nStart from the second element (index 1).\nCompare it with elements before it.\nShift larger elements one position to the right.\nInsert the current element into the correct position.\nRepeat for all elements.\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        // Move elements greater than key to one position ahead\n        while (j &gt;= 0 && arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Insertion Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Binary_Search.html",
    "href": "DSA Notes/Binary_Search.html",
    "title": "Binary Search",
    "section": "",
    "text": "üìñ Theory\nBinary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\n\n\n‚úÖ Code (C++)\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n    }\n    return -1; // Not found\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary_Search.html#binary-search",
    "href": "DSA Notes/Binary_Search.html#binary-search",
    "title": "DSA",
    "section": "",
    "text": "Binary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\n\n\n\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n    }\n    return -1; // Not found\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/Binary_Search.html",
    "href": "DSA Notes/Binary Search/Binary_Search.html",
    "title": "Binary Search",
    "section": "",
    "text": "üìñ Theory\nBinary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\nApplications:\n\nUsed in searching in sorted arrays.\nLower/upper bound problems.\nFinding insert position in sorted data.\n\n\nExtra Things to Know:\n\nSome times we face issue of index out of range. In such cases try taking s = 1 and e = n - 2. And ensure conditions on 0 and n - 1 before applying the while loop.\n\n\n\n\n‚úÖ Code (C++)\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return -1; // Not found\n}\nRecursive Verison\nint binarySearchRecursive(const vector&lt;int&gt;& arr, int s, int e, int target) {\n    if (s &gt; e) {\n        return -1;\n    }\n    int mid = s + (e - s) / 2;\n    if (arr[mid] == target) {\n        return mid;\n    }\n    else if (arr[mid] &lt; target) {\n        return binarySearchRecursive(arr, mid + 1, e, target);\n    }\n    else {\n        return binarySearchRecursive(arr, s, mid - 1, target);\n    }\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/BS_rotated_no_dupli.html",
    "href": "DSA Notes/Binary Search/BS_rotated_no_dupli.html",
    "title": "Binary Search in Rotated Sorted Array (No Duplicates)",
    "section": "",
    "text": "üìñ Theory\nThe array will be like {5, 6, 7, 8, 1, 2, 3}, here we have to find target element with the help of Binary Search.\n\nSteps:\n\nTo find the pivot index (index of the smallest element), set s = 0, e = n - 1.\nWhile s &lt; e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] &gt;= arr[0], set s = mid + 1.\nElse set e = mid.\n\nAfter the loop, s will be the index of the smallest element (pivot).\nCompare the target element with arr[0]:\n\nIf target &gt;= arr[0], apply binary search on the range [0, pivot - 1].\nElse, apply binary search on the range [pivot, n - 1].\n\n\n\n\n\n‚úÖ Code (C++)\nint pivot(vector &lt;int&gt; &arr) {\n    int s = 0, e = arr.size() - 1;\n\n    // Non rotated sorted array\n    if (arr[s] &lt;= arr[e]) {\n        return 0;\n    }\n\n    int mid = s + (e - s) / 2;\n    while (s &lt; e) {\n        if (arr[mid] &gt;= arr[0]) {\n            s = mid + 1;\n        }\n        else {\n            e = mid;\n        }\n        mid = s + (e - s) / 2;\n    }\n\n    return s;\n}\n\n// Now apply Binary Search",
    "crumbs": [
      "Home",
      "Binary Search",
      "BS in Rotated Array (No Duplicates)"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/BS_rotated_dupli.html",
    "href": "DSA Notes/Binary Search/BS_rotated_dupli.html",
    "title": "Binary Search in Rotated Sorted Array (With Duplicates)",
    "section": "",
    "text": "üìñ Theory\nThe array will be like {3, 3, 5, 6, 7, 8, 8, 8, 1, 2, 3}, here we have to find target element with the help of Binary Search.\n\nSteps:\n\nTo find the pivot index (index of the smallest element), set s = 0, e = n - 1.\nWhile s &lt; e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] &gt; arr[e], set s = mid + 1.\nElse if arr[mid] &lt; arr[e], set e = mid.\nElse (arr[mid] == arr[e]), decrement e by 1.\n\nAfter the loop, s will be the index of the smallest element (pivot).\nCompare the target element with arr[0]:\n\nIf target &gt;= arr[0], apply binary search on the range [0, pivot - 1].\nElse, apply binary search on the range [pivot, n - 1].\n\n\n\n\n\n‚úÖ Code (C++)\nint pivot(vector &lt;int&gt; &arr) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt; e) {\n        if (arr[mid] &gt; arr[e]) {\n            s = mid + 1;        \n        }\n        else if (arr[mid] &lt; arr[e]) {\n            e = mid;             \n        }\n        else {\n            e--;                  \n        }\n        mid = s + (e - s) / 2;\n    }\n\n    return s;\n}\n\n// Now apply Binary Search",
    "crumbs": [
      "Home",
      "Binary Search",
      "BS in Rotated Array (Duplicates)"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html",
    "href": "DSA Notes/Recursion/recursion.html",
    "title": "Recursion",
    "section": "",
    "text": "üìñ Theory\nRecursion is a programming technique where a function calls itself to solve smaller instances of a problem.\n\nWhy Use Recursion?\n\nSimplifies code for problems that have a natural recursive structure (e.g., trees, graphs, divide & conquer).\nMakes code easier to read for certain problems.\n\n\nKey Concepts\n\nBase Case: The condition under which the recursion ends. Prevents infinite recursion.\nProcessing: Where you perform some opeartions before next recursive call.\nRecursive Case: The part where the function calls itself with a smaller or simpler input.\n\n\nAnatomy of a Recursive Function\nvoid recursiveFunction(parameters) {\n    if (base_case_condition) {\n        // Handle base case\n        return;\n    }\n\n    // Processing\n\n    // Recursive call(s)\n    recursiveFunction(smaller_problem);\n}\n\nExample 1: Factorial\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}\nExample 2: Fibonacci Numbers\nint fibonacci(int n) {\n    if (n &lt;= 1) return n; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}\n\nHow Recursion Works (Call Stack)\n\nEach recursive call adds a new frame to the call stack.\nWhen a base case is reached, the stack unwinds.\n\nCommon Mistakes\n\nMissing base case: Leads to infinite recursion (stack overflow).\nIncorrect base case: May cause wrong results.\nNot reducing the problem: The recursive call must progress toward the base case.\n\nWhen to Use Recursion\n\nProblems that can be broken into similar subproblems (e.g., tree traversals, searching, sorting).\nWhen iterative solutions are complex or less readable.\n\n\nAdvanced Recursion\n\nBacktracking: Used for problems like permutations, combinations, N-Queens, Sudoku.\nDivide and Conquer: Algorithms like Merge Sort, Quick Sort use recursion to divide the problem.\nDynamic Programming (Memoization): Optimize recursive solutions by storing results of subproblems.\n\n\nExample: Backtracking (N-Queens)\nvoid solveNQueens(int row, vector&lt;string&gt;& board, vector&lt;vector&lt;string&gt;&gt;& solutions) {\n    if (row == board.size()) {\n        solutions.push_back(board);\n        return;\n    }\n    for (int col = 0; col &lt; board.size(); col++) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueens(row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}\n\nTips to Master Recursion\n\nDraw the recursion tree for small inputs.\nTrace the call stack step by step.\nStart with the base case and build up.\n\n\nRecursion vs Iteration\n\n\n\nRecursion\nIteration\n\n\n\n\nElegant for some problems\nUsually more efficient\n\n\nUses call stack\nUses loop variables\n\n\nCan be less efficient\nOften faster and uses less memory",
    "crumbs": [
      "Home",
      "Recursion",
      "Recursion"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#what-is-recursion",
    "href": "DSA Notes/Recursion/recursion.html#what-is-recursion",
    "title": "Recursion",
    "section": "",
    "text": "Recursion is a programming technique where a function calls itself to solve smaller instances of a problem."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#why-use-recursion",
    "href": "DSA Notes/Recursion/recursion.html#why-use-recursion",
    "title": "Recursion",
    "section": "Why Use Recursion?",
    "text": "Why Use Recursion?\n\nSimplifies code for problems that have a natural recursive structure (e.g., trees, graphs, divide & conquer).\nMakes code easier to read for certain problems."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#key-concepts",
    "href": "DSA Notes/Recursion/recursion.html#key-concepts",
    "title": "Recursion",
    "section": "Key Concepts",
    "text": "Key Concepts\n\n1. Base Case\nThe condition under which the recursion ends. Prevents infinite recursion.\n\n\n2. Recursive Case\nThe part where the function calls itself with a smaller or simpler input."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#anatomy-of-a-recursive-function",
    "href": "DSA Notes/Recursion/recursion.html#anatomy-of-a-recursive-function",
    "title": "Recursion",
    "section": "Anatomy of a Recursive Function",
    "text": "Anatomy of a Recursive Function\nvoid recursiveFunction(parameters) {\n    if (base_case_condition) {\n        // Handle base case\n        return;\n    }\n    // Recursive call(s)\n    recursiveFunction(smaller_problem);\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-1-factorial",
    "href": "DSA Notes/Recursion/recursion.html#example-1-factorial",
    "title": "Recursion",
    "section": "Example 1: Factorial",
    "text": "Example 1: Factorial\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-2-fibonacci-numbers",
    "href": "DSA Notes/Recursion/recursion.html#example-2-fibonacci-numbers",
    "title": "Recursion",
    "section": "Example 2: Fibonacci Numbers",
    "text": "Example 2: Fibonacci Numbers\nint fibonacci(int n) {\n    if (n &lt;= 1) return n; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#how-recursion-works-call-stack",
    "href": "DSA Notes/Recursion/recursion.html#how-recursion-works-call-stack",
    "title": "Recursion",
    "section": "How Recursion Works (Call Stack)",
    "text": "How Recursion Works (Call Stack)\n\nEach recursive call adds a new frame to the call stack.\nWhen a base case is reached, the stack unwinds."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#common-mistakes",
    "href": "DSA Notes/Recursion/recursion.html#common-mistakes",
    "title": "Recursion",
    "section": "Common Mistakes",
    "text": "Common Mistakes\n\nMissing base case: Leads to infinite recursion (stack overflow).\nIncorrect base case: May cause wrong results.\nNot reducing the problem: The recursive call must progress toward the base case."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#when-to-use-recursion",
    "href": "DSA Notes/Recursion/recursion.html#when-to-use-recursion",
    "title": "Recursion",
    "section": "When to Use Recursion",
    "text": "When to Use Recursion\n\nProblems that can be broken into similar subproblems (e.g., tree traversals, searching, sorting).\nWhen iterative solutions are complex or less readable."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#practice-problems",
    "href": "DSA Notes/Recursion/recursion.html#practice-problems",
    "title": "Recursion",
    "section": "Practice Problems",
    "text": "Practice Problems\n\nSum of Array: Write a recursive function to sum all elements of an array.\nReverse a String: Recursively reverse a string.\nPower Function: Compute a^b recursively.\nCheck Palindrome: Check if a string is a palindrome using recursion.\nTower of Hanoi: Classic recursion puzzle."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#advanced-recursion",
    "href": "DSA Notes/Recursion/recursion.html#advanced-recursion",
    "title": "Recursion",
    "section": "Advanced Recursion",
    "text": "Advanced Recursion\n\n1. Backtracking\nUsed for problems like permutations, combinations, N-Queens, Sudoku.\n\n\n2. Divide and Conquer\nAlgorithms like Merge Sort, Quick Sort use recursion to divide the problem.\n\n\n3. Dynamic Programming (Memoization)\nOptimize recursive solutions by storing results of subproblems."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-backtracking-n-queens",
    "href": "DSA Notes/Recursion/recursion.html#example-backtracking-n-queens",
    "title": "Recursion",
    "section": "Example: Backtracking (N-Queens)",
    "text": "Example: Backtracking (N-Queens)\nvoid solveNQueens(int row, vector&lt;string&gt;& board, vector&lt;vector&lt;string&gt;&gt;& solutions) {\n    if (row == board.size()) {\n        solutions.push_back(board);\n        return;\n    }\n    for (int col = 0; col &lt; board.size(); col++) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueens(row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#tips-to-master-recursion",
    "href": "DSA Notes/Recursion/recursion.html#tips-to-master-recursion",
    "title": "Recursion",
    "section": "Tips to Master Recursion",
    "text": "Tips to Master Recursion\n\nDraw the recursion tree for small inputs.\nTrace the call stack step by step.\nStart with the base case and build up.\nPractice! The more problems you solve, the better you‚Äôll understand recursion."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#recursion-vs-iteration",
    "href": "DSA Notes/Recursion/recursion.html#recursion-vs-iteration",
    "title": "Recursion",
    "section": "Recursion vs Iteration",
    "text": "Recursion vs Iteration\n\n\n\nRecursion\nIteration\n\n\n\n\nElegant for some problems\nUsually more efficient\n\n\nUses call stack\nUses loop variables\n\n\nCan be less efficient\nOften faster and uses less memory"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#summary",
    "href": "DSA Notes/Recursion/recursion.html#summary",
    "title": "Recursion",
    "section": "Summary",
    "text": "Summary\n\nRecursion is a powerful tool for solving complex problems.\nAlways define a clear base case.\nPractice with classic problems to build intuition."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#further-reading",
    "href": "DSA Notes/Recursion/recursion.html#further-reading",
    "title": "Recursion",
    "section": "Further Reading",
    "text": "Further Reading\n\nRecursion (GeeksforGeeks)\nVisualgo Recursion Visualizer\nLeetCode Recursion Problems"
  },
  {
    "objectID": "DSA Notes/Recursion/finding_power_set.html",
    "href": "DSA Notes/Recursion/finding_power_set.html",
    "title": "Finding the Power Set",
    "section": "",
    "text": "üìñ Theory\nYou will be given an array like {1, 2, 3} or a string ‚Äúabc‚Äù. You need to find out all possible subsets, e.g.:\n\nFor {1, 2, 3}: {[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]}\nFor ‚Äúabc‚Äù: {‚Äú‚Äú,‚Äùa‚Äù, ‚Äúab‚Äù, ‚Äúabc‚Äù, ‚Äúac‚Äù, ‚Äúb‚Äù, ‚Äúbc‚Äù, ‚Äúc‚Äù}\n\n\nUsing Recursion\n\nAt each step, decide to include or exclude the current element.\nBase Case: If i &gt;= arr.size(), print or store the current subset.\n\n  Base Case:\n    i &gt;= arr.size();\n\n   i        output                            \n  {1, 2, 3} , {}\n   |                         i      output\n   |-- |-- include 1 --&gt; {1, 2, 3} , {1,}\n       |                     |                        i    output              \n       |                     |-- include 2 --&gt; {1, 2, 3} , {1, 2}\n       |                     |                        i    output\n       |                     |-- exclude 2 --&gt; {1, 2, 3} , {1,}\n       |\n       |                     i      output\n       |-- exclude 1 --&gt; {1, 2, 3} , {}\n       |                     |                        i    output              \n       |                     |-- include 2 --&gt; {1, 2, 3} , {2}\n       |                     |                        i    output\n       |                     |-- exclude 2 --&gt; {1, 2, 3} , {}\n\nLike wise include and exclude the next numbers recursively.",
    "crumbs": [
      "Home",
      "Recursion",
      "Finding the Power Set"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/pairing_two_or_multiple_sets.html",
    "href": "DSA Notes/Recursion/pairing_two_or_multiple_sets.html",
    "title": "Paring of Two or Multiple Arrays",
    "section": "",
    "text": "üìñ Theory\nWe will be given with [[a, b, c], [x, y, z]] and need to pair them in all possible ways as ax, ay, az, bx and so on.\n\nUsing Recursion\n\nAt each step (for each array), pick one element from the current array.\nMove to the next array and repeat the process, building up the current combination.\nBase Case: If you have picked one element from each array (i.e., reached the end), print or store the current combination.\nThis approach generates all possible pairings (or tuples) by exploring every choice at each level.\n\n  Base Case:\n    i &gt;= arr.size();\n\n  (   i   )             output\n  [a, b, c] & [x, y, z] , {}\n      |               (   i   )  output              (   i   )  output              (   i   )  output\n      |-- [a, b, c] & [x, y, z] , {a,} & [a, b, c] & [x, y, z] , {b,} & [a, b, c] & [x, y, z] , {c,}\n                          |\n                          |                       &lt; i output                       &lt; i output                       &lt; i output\n                          |-- [a, b, c] & [x, y, z] , {a, x} & [a, b, c] & [x, y, z] , {a, y} & [a, b, c] & [x, y, z] , {a, z}  \nLike wise bx, by, bz and cx, cy, cz.",
    "crumbs": [
      "Home",
      "Recursion",
      "Paring of Two or Multiple Arrays"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html",
    "href": "DSA Notes/C++STL/vector.html",
    "title": "Vector",
    "section": "",
    "text": "vector&lt;T&gt; v;\nDeclares an empty vector of type T.\nvector&lt;int&gt; v(10, 0);\nInitializes a vector of 10 integers, all set to 0.\nvector&lt;char&gt; v2(v1);\nCopies all elements from vector v1 to v2.\nvector&lt;int&gt; v = {1, 2, 3};\nInitializes a vector with given values.\nv.assign(n, value);\nAssigns n copies of value to the vector, replacing current contents.\nv.size();\nReturns the number of elements in the vector.\nv.capacity();\nReturns the size of the storage space currently allocated (can be greater than or equal to size).\nv.max_size();\nReturns the maximum number of elements the vector can hold.\nv.resize(n);\nChanges the size of the vector to n.¬†If n is greater, new elements are default-initialized.\nv.push_back(x);\nAppends element x to the end of the vector.\nv.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nv.at(i);\nReturns the element at index i (with bounds checking).\nv[i];\nReturns the element at index i (no bounds checking).\nv.front();\nReturns the first element.\nv.back();\nReturns the last element.\nv.pop_back();\nRemoves the last element.\nv.clear();\nRemoves all elements. Size becomes 0, but capacity (allocated memory) remains unchanged.\nv.empty();\nReturns true if the vector is empty.\nv.swap(v2);\nSwaps the contents of v and v2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#important-points-related-to-vectors",
    "href": "DSA Notes/C++STL/vector.html#important-points-related-to-vectors",
    "title": "Vector",
    "section": "",
    "text": "vector&lt;T&gt; v;\nDeclares an empty vector of type T.\nvector&lt;int&gt; v(10, 0);\nInitializes a vector of 10 integers, all set to 0.\nvector&lt;char&gt; v2(v1);\nCopies all elements from vector v1 to v2.\nvector&lt;int&gt; v = {1, 2, 3};\nInitializes a vector with given values.\nv.assign(n, value);\nAssigns n copies of value to the vector, replacing current contents.\nv.size();\nReturns the number of elements in the vector.\nv.capacity();\nReturns the size of the storage space currently allocated (can be greater than or equal to size).\nv.max_size();\nReturns the maximum number of elements the vector can hold.\nv.resize(n);\nChanges the size of the vector to n.¬†If n is greater, new elements are default-initialized.\nv.push_back(x);\nAppends element x to the end of the vector.\nv.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nv.at(i);\nReturns the element at index i (with bounds checking).\nv[i];\nReturns the element at index i (no bounds checking).\nv.front();\nReturns the first element.\nv.back();\nReturns the last element.\nv.pop_back();\nRemoves the last element.\nv.clear();\nRemoves all elements. Size becomes 0, but capacity (allocated memory) remains unchanged.\nv.empty();\nReturns true if the vector is empty.\nv.swap(v2);\nSwaps the contents of v and v2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#useful-operations",
    "href": "DSA Notes/C++STL/vector.html#useful-operations",
    "title": "Vector",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nsort(v.begin(), v.end());\nSorts the vector in ascending order. Time: O(N log N).\nreverse(v.begin(), v.end());\nReverses the order of elements.\nv.erase(v.begin() + i);\nRemoves the element at index i.\nv.erase(v.begin() + i, v.begin() + j);\nRemoves elements from index i up to (but not including) index j. Time: O(N).\nv.insert(v.begin() + i, x);\nInserts element x at index i.\nv.insert(v.begin() + i, n, x);\nInserts n copies of x at index i.\nv.insert(v.end(), {a, b, c});\nInserts multiple elements at the end.\nfind(v.begin(), v.end(), x);\nReturns an iterator to the first occurrence of x (or v.end() if not found). Time: O(N).\nlower_bound(v.begin(), v.end(), x);\nReturns iterator to the first element not less than x (vector must be sorted).\nupper_bound(v.begin(), v.end(), x);\nReturns iterator to the first element greater than x (vector must be sorted).\naccumulate(v.begin(), v.end(), 0);\nReturns the sum of all elements (requires #include &lt;numeric&gt;).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#notes",
    "href": "DSA Notes/C++STL/vector.html#notes",
    "title": "Vector",
    "section": "Notes",
    "text": "Notes\n\nVectors are dynamic arrays; they resize automatically as elements are added or removed.\nMemory is contiguous, so vectors can be passed to C-style functions expecting arrays.\nAccessing elements out of bounds with v[i] is undefined behavior; use v.at(i) for safety.\nIterators become invalid after insertions or deletions (except at the end).\nTo shrink capacity to fit size, use: v.shrink_to_fit();\nInserting or erasing elements at the end is fast (amortized O(1)), but at other positions it is O(N).\nUse reserve(n) to pre-allocate memory if the number of elements is known in advance to avoid multiple reallocations.\nVectors are not thread-safe by default; use mutexes for multi-threaded scenarios.\nSuitable for situations where you need fast random access and frequent insertions/removals at the end.\nIf you need to insert or remove elements frequently at the beginning or middle, consider using deque or list.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#iterating-over-a-vector",
    "href": "DSA Notes/C++STL/vector.html#iterating-over-a-vector",
    "title": "Vector",
    "section": "Iterating Over a Vector",
    "text": "Iterating Over a Vector\n\nUsing index:\nfor (int i = 0; i &lt; v.size(); i++) { access v[i] }\nUsing iterator:\nfor (auto it = v.begin(); it != v.end(); ++it) { access *it }\nUsing range-based for loop:\nfor (auto x : v) { access x }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html",
    "href": "DSA Notes/C++STL/deque.html",
    "title": "Deque",
    "section": "",
    "text": "deque&lt;T&gt; d;\nDeclares an empty deque of type T.\ndeque&lt;int&gt; d(10, 0);\nInitializes a deque of 10 integers, all set to 0.\ndeque&lt;char&gt; d2(d1);\nCopies all elements from deque d1 to d2.\ndeque&lt;int&gt; d = {1, 2, 3};\nInitializes a deque with given values.\nd.assign(n, value);\nAssigns n copies of value to the deque, replacing current contents.\nd.size();\nReturns the number of elements in the deque.\nd.max_size();\nReturns the maximum number of elements the deque can hold.\nd.resize(n);\nChanges the size of the deque to n.¬†If n is greater, new elements are default-initialized.\nd.push_back(x);\nAppends element x to the end of the deque.\nd.push_front(x);\nInserts element x at the beginning of the deque.\nd.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nd.emplace_front(args);\nConstructs element in-place at the front.\nd.at(i);\nReturns the element at index i (with bounds checking).\nd[i];\nReturns the element at index i (no bounds checking).\nd.front();\nReturns the first element.\nd.back();\nReturns the last element.\nd.pop_back();\nRemoves the last element.\nd.pop_front();\nRemoves the first element.\nd.clear();\nRemoves all elements. Size becomes 0.\nd.empty();\nReturns true if the deque is empty.\nd.swap(d2);\nSwaps the contents of d and d2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#important-points-related-to-deques",
    "href": "DSA Notes/C++STL/deque.html#important-points-related-to-deques",
    "title": "Deque",
    "section": "",
    "text": "deque&lt;T&gt; d;\nDeclares an empty deque of type T.\ndeque&lt;int&gt; d(10, 0);\nInitializes a deque of 10 integers, all set to 0.\ndeque&lt;char&gt; d2(d1);\nCopies all elements from deque d1 to d2.\ndeque&lt;int&gt; d = {1, 2, 3};\nInitializes a deque with given values.\nd.assign(n, value);\nAssigns n copies of value to the deque, replacing current contents.\nd.size();\nReturns the number of elements in the deque.\nd.max_size();\nReturns the maximum number of elements the deque can hold.\nd.resize(n);\nChanges the size of the deque to n.¬†If n is greater, new elements are default-initialized.\nd.push_back(x);\nAppends element x to the end of the deque.\nd.push_front(x);\nInserts element x at the beginning of the deque.\nd.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nd.emplace_front(args);\nConstructs element in-place at the front.\nd.at(i);\nReturns the element at index i (with bounds checking).\nd[i];\nReturns the element at index i (no bounds checking).\nd.front();\nReturns the first element.\nd.back();\nReturns the last element.\nd.pop_back();\nRemoves the last element.\nd.pop_front();\nRemoves the first element.\nd.clear();\nRemoves all elements. Size becomes 0.\nd.empty();\nReturns true if the deque is empty.\nd.swap(d2);\nSwaps the contents of d and d2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#useful-operations",
    "href": "DSA Notes/C++STL/deque.html#useful-operations",
    "title": "Deque",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nsort(d.begin(), d.end());\nSorts the deque in ascending order. Time: O(N log N).\nreverse(d.begin(), d.end());\nReverses the order of elements.\nd.erase(d.begin() + i);\nRemoves the element at index i.\nd.erase(d.begin() + i, d.begin() + j);\nRemoves elements from index i up to (but not including) index j.\nd.insert(d.begin() + i, x);\nInserts element x at index i.\nd.insert(d.begin() + i, n, x);\nInserts n copies of x at index i.\nd.insert(d.end(), {a, b, c});\nInserts multiple elements at the end.\nfind(d.begin(), d.end(), x);\nReturns an iterator to the first occurrence of x (or d.end() if not found).\nlower_bound(d.begin(), d.end(), x);\nReturns iterator to the first element not less than x (deque must be sorted).\nupper_bound(d.begin(), d.end(), x);\nReturns iterator to the first element greater than x (deque must be sorted).\naccumulate(d.begin(), d.end(), 0);\nReturns the sum of all elements (requires #include &lt;numeric&gt;).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#iterating-over-a-deque",
    "href": "DSA Notes/C++STL/deque.html#iterating-over-a-deque",
    "title": "Deque",
    "section": "Iterating Over a Deque",
    "text": "Iterating Over a Deque\n\nUsing index:\nfor (int i = 0; i &lt; d.size(); i++) { access d[i] }\nUsing iterator:\nfor (auto it = d.begin(); it != d.end(); ++it) { access *it }\nUsing range-based for loop:\nfor (auto x : d) { access x }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#notes",
    "href": "DSA Notes/C++STL/deque.html#notes",
    "title": "Deque",
    "section": "Notes",
    "text": "Notes\n\nDeques (double-ended queues) allow fast insertion and deletion at both the front and back (O(1) time).\nRandom access to elements is O(1), similar to vector.\nMemory is not guaranteed to be contiguous (unlike vector).\nAccessing elements out of bounds with d[i] is undefined behavior; use d.at(i) for safety.\nIterators may become invalid after insertions or deletions.\nDeques are useful when you need to add or remove elements from both ends frequently.\nNo capacity() or shrink_to_fit() functions, as memory management is handled differently than vector.\nUse reserve() is not available for deque.\nDeques are generally slower than vectors for pure back operations due to more complex memory management.\nSuitable for implementing both stacks and queues efficiently.\nStandard library queue and stack containers use deque as the default underlying container.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#when-to-use-deque",
    "href": "DSA Notes/C++STL/deque.html#when-to-use-deque",
    "title": "Deque",
    "section": "When to Use Deque",
    "text": "When to Use Deque\n\nWhen you need fast insertions and deletions at both the front and back.\nWhen you need random access to elements (like vector).\nWhen memory contiguity is not a strict requirement.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#additional-points",
    "href": "DSA Notes/C++STL/deque.html#additional-points",
    "title": "Deque",
    "section": "Additional Points",
    "text": "Additional Points\n\nDeques may allocate memory in multiple chunks, so their memory is not guaranteed to be contiguous.\nThere is no direct way to reduce the memory usage of a deque (no shrink_to_fit).\nDeques do not support the reserve function.\nIf you need contiguous memory, use vector instead.\nFor multi-threaded use, consider using mutexes or thread-safe containers.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html",
    "href": "DSA Notes/C++STL/stack.html",
    "title": "Stack",
    "section": "",
    "text": "stack&lt;T&gt; s;\nDeclares an empty stack of type T.\nstack&lt;int&gt; s2(s1);\nCopies all elements from stack s1 to s2.\nstack&lt;int&gt; s = stack&lt;int&gt;();\nInitializes an empty stack of integers.\ns.size();\nReturns the number of elements in the stack.\ns.empty();\nReturns true if the stack is empty.\ns.push(x);\nPushes element x onto the top of the stack.\ns.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\ns.pop();\nRemoves the top element (does not return it).\ns.top();\nReturns a reference to the top element.\ns.swap(s2);\nSwaps the contents of s and s2.\nThere is no direct way to access elements other than the top.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#important-points-related-to-stacks",
    "href": "DSA Notes/C++STL/stack.html#important-points-related-to-stacks",
    "title": "Stack",
    "section": "",
    "text": "stack&lt;T&gt; s;\nDeclares an empty stack of type T.\nstack&lt;int&gt; s2(s1);\nCopies all elements from stack s1 to s2.\nstack&lt;int&gt; s = stack&lt;int&gt;();\nInitializes an empty stack of integers.\ns.size();\nReturns the number of elements in the stack.\ns.empty();\nReturns true if the stack is empty.\ns.push(x);\nPushes element x onto the top of the stack.\ns.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\ns.pop();\nRemoves the top element (does not return it).\ns.top();\nReturns a reference to the top element.\ns.swap(s2);\nSwaps the contents of s and s2.\nThere is no direct way to access elements other than the top.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#example-usage",
    "href": "DSA Notes/C++STL/stack.html#example-usage",
    "title": "Stack",
    "section": "Example Usage",
    "text": "Example Usage\n\nCreating a stack of integers:\nstack&lt;int&gt; s;\nPushing elements:\ns.push(10);\ns.push(20);\ns.push(30); // Stack is now: 10 (bottom), 20, 30 (top)\nAccessing the top element:\nint x = s.top(); // x = 30\nRemoving the top element:\ns.pop(); // Stack is now: 10 (bottom), 20 (top)\nChecking if stack is empty:\nif (s.empty()) { /* stack is empty */ }\nGetting the size:\nint n = s.size();",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#notes",
    "href": "DSA Notes/C++STL/stack.html#notes",
    "title": "Stack",
    "section": "Notes",
    "text": "Notes\n\nStack is a container adapter; by default, it uses deque as the underlying container (can also use vector or list).\nFollows Last-In-First-Out (LIFO) principle.\nNo iterators are provided; you cannot traverse a stack.\nOnly the top element can be accessed or removed.\nUseful for function call management, expression evaluation, backtracking, undo operations, etc.\nTo clear a stack, repeatedly call pop() until empty.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#when-to-use-stack",
    "href": "DSA Notes/C++STL/stack.html#when-to-use-stack",
    "title": "Stack",
    "section": "When to Use Stack",
    "text": "When to Use Stack\n\nWhen you need LIFO (Last-In-First-Out) access.\nFor problems involving recursion, parsing, or backtracking.\nWhen only the most recently added element needs to be accessed or removed.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#additional-points",
    "href": "DSA Notes/C++STL/stack.html#additional-points",
    "title": "Stack",
    "section": "Additional Points",
    "text": "Additional Points\n\nYou can specify the underlying container:\nstack&lt;int, vector&lt;int&gt;&gt; s2; // Uses vector as the underlying container\nstack&lt;int, deque&lt;int&gt;&gt; s3; // Uses deque (default)\nStandard library stack does not support iteration or random access.\nIf you need to traverse or access elements, consider using deque or vector directly.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#limitations",
    "href": "DSA Notes/C++STL/stack.html#limitations",
    "title": "Stack",
    "section": "Limitations",
    "text": "Limitations\n\nCannot access or modify elements other than the top.\nNo direct way to clear all elements at once (must pop each element).\nNo iterators or random access.\nNot thread-safe by default.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#common-applications",
    "href": "DSA Notes/C++STL/stack.html#common-applications",
    "title": "Stack",
    "section": "Common Applications",
    "text": "Common Applications\n\nUndo/Redo functionality in editors.\nSyntax parsing (parentheses matching, expression evaluation).\nBacktracking algorithms (DFS, maze solving).\nFunction call stack in recursion.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#tips",
    "href": "DSA Notes/C++STL/stack.html#tips",
    "title": "Stack",
    "section": "Tips",
    "text": "Tips\n\nIf you need to access elements other than the top, use vector or deque directly.\nFor multi-threaded use, consider using mutexes or thread-safe containers.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html",
    "href": "DSA Notes/C++STL/set.html",
    "title": "Set",
    "section": "",
    "text": "set&lt;T&gt; s;\nDeclares an empty set of type T (elements are unique and sorted).\nset&lt;int&gt; s = {1, 2, 3};\nInitializes a set with given values.\nset&lt;int&gt; s2(s1);\nCopies all elements from set s1 to s2.\ns.insert(x);\nInserts element x into the set (if not already present).\ns.erase(x);\nRemoves element x from the set (if present).\ns.erase(it);\nRemoves the element pointed to by iterator it.\ns.erase(s.begin(), s.end());\nRemoves all elements in the given range.\ns.find(x);\nReturns an iterator to x if found, else s.end().\ns.count(x);\nReturns 1 if x is present, 0 otherwise.\ns.size();\nReturns the number of elements in the set.\ns.empty();\nReturns true if the set is empty.\ns.clear();\nRemoves all elements from the set.\ns.lower_bound(x);\nReturns iterator to the first element not less than x.\ns.upper_bound(x);\nReturns iterator to the first element greater than x.\ns.swap(s2);\nSwaps the contents of s and s2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#important-points-related-to-sets",
    "href": "DSA Notes/C++STL/set.html#important-points-related-to-sets",
    "title": "Set",
    "section": "",
    "text": "set&lt;T&gt; s;\nDeclares an empty set of type T (elements are unique and sorted).\nset&lt;int&gt; s = {1, 2, 3};\nInitializes a set with given values.\nset&lt;int&gt; s2(s1);\nCopies all elements from set s1 to s2.\ns.insert(x);\nInserts element x into the set (if not already present).\ns.erase(x);\nRemoves element x from the set (if present).\ns.erase(it);\nRemoves the element pointed to by iterator it.\ns.erase(s.begin(), s.end());\nRemoves all elements in the given range.\ns.find(x);\nReturns an iterator to x if found, else s.end().\ns.count(x);\nReturns 1 if x is present, 0 otherwise.\ns.size();\nReturns the number of elements in the set.\ns.empty();\nReturns true if the set is empty.\ns.clear();\nRemoves all elements from the set.\ns.lower_bound(x);\nReturns iterator to the first element not less than x.\ns.upper_bound(x);\nReturns iterator to the first element greater than x.\ns.swap(s2);\nSwaps the contents of s and s2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#useful-operations",
    "href": "DSA Notes/C++STL/set.html#useful-operations",
    "title": "Set",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nIterating over a set (ascending order):\nfor (auto it = s.begin(); it != s.end(); ++it) { access *it }\nRange-based for loop:\nfor (auto x : s) { access x }\nReverse iteration:\nfor (auto it = s.rbegin(); it != s.rend(); ++it) { access *it }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#notes",
    "href": "DSA Notes/C++STL/set.html#notes",
    "title": "Set",
    "section": "Notes",
    "text": "Notes\n\nset stores unique elements in sorted order (by default, ascending).\nAll operations (insert, erase, find, count, lower_bound, upper_bound) have O(log N) time complexity.\nUnderlying data structure is usually a balanced BST (like Red-Black Tree).\nElements are immutable; you cannot modify elements in-place.\nIf you need to store duplicate elements, use multiset.\nIf you need faster operations and do not require ordering, use unordered_set (average O(1) time).\nset does not provide random access (no operator[]).\nIterators remain valid except for erased elements.\nFor custom sorting, provide a comparator as a template argument.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#when-to-use-set",
    "href": "DSA Notes/C++STL/set.html#when-to-use-set",
    "title": "Set",
    "section": "When to Use Set",
    "text": "When to Use Set\n\nWhen you need to maintain a collection of unique, sorted elements.\nWhen you need fast search, insertion, and deletion (O(log N)).\nWhen order of elements matters.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#additional-points",
    "href": "DSA Notes/C++STL/set.html#additional-points",
    "title": "Set",
    "section": "Additional Points",
    "text": "Additional Points\n\nset&lt;int, greater&lt;int&gt;&gt; s; // Stores elements in descending order.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nset can be used for removing duplicates, set operations (union, intersection, difference), and maintaining ordered unique collections.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html",
    "href": "DSA Notes/C++STL/priority_queue.html",
    "title": "Priority Queue",
    "section": "",
    "text": "priority_queue&lt;T&gt; pq;\nDeclares a max-heap priority queue of type T (largest element at top).\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nDeclares a min-heap priority queue (smallest element at top).\npriority_queue&lt;T&gt; pq1(pq2);\nCopies all elements from pq2 to pq1.\npq.push(x);\nInserts element x into the priority queue.\npq.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\npq.pop();\nRemoves the top element.\npq.top();\nReturns a reference to the top element.\npq.size();\nReturns the number of elements in the priority queue.\npq.empty();\nReturns true if the priority queue is empty.\npq.swap(pq2);\nSwaps the contents of pq and pq2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#important-points-related-to-priority-queues",
    "href": "DSA Notes/C++STL/priority_queue.html#important-points-related-to-priority-queues",
    "title": "Priority Queue",
    "section": "",
    "text": "priority_queue&lt;T&gt; pq;\nDeclares a max-heap priority queue of type T (largest element at top).\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nDeclares a min-heap priority queue (smallest element at top).\npriority_queue&lt;T&gt; pq1(pq2);\nCopies all elements from pq2 to pq1.\npq.push(x);\nInserts element x into the priority queue.\npq.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\npq.pop();\nRemoves the top element.\npq.top();\nReturns a reference to the top element.\npq.size();\nReturns the number of elements in the priority queue.\npq.empty();\nReturns true if the priority queue is empty.\npq.swap(pq2);\nSwaps the contents of pq and pq2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#example-usage",
    "href": "DSA Notes/C++STL/priority_queue.html#example-usage",
    "title": "Priority Queue",
    "section": "Example Usage",
    "text": "Example Usage\n\nMax-heap (default):\npriority_queue&lt;int&gt; pq;\npq.push(10); pq.push(5); pq.push(20);\npq.top(); // 20\nMin-heap:\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\npq.push(10); pq.push(5); pq.push(20);\npq.top(); // 5",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#notes",
    "href": "DSA Notes/C++STL/priority_queue.html#notes",
    "title": "Priority Queue",
    "section": "Notes",
    "text": "Notes\n\nBy default, priority_queue is a max-heap (top() returns the largest element).\nTo create a min-heap, use greater&lt;T&gt; as the third template argument.\nUnderlying container is usually vector (can also use deque).\nNo direct way to access elements other than the top.\nNo iterators or random access.\nNot thread-safe by default.\nUseful for greedy algorithms, Dijkstra‚Äôs algorithm, scheduling, etc.\nTo clear a priority queue, repeatedly call pop() until empty.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#when-to-use-priority-queue",
    "href": "DSA Notes/C++STL/priority_queue.html#when-to-use-priority-queue",
    "title": "Priority Queue",
    "section": "When to Use Priority Queue",
    "text": "When to Use Priority Queue\n\nWhen you need quick access to the largest or smallest element.\nFor problems involving ordering by priority (e.g., task scheduling, shortest path).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#additional-points",
    "href": "DSA Notes/C++STL/priority_queue.html#additional-points",
    "title": "Priority Queue",
    "section": "Additional Points",
    "text": "Additional Points\n\nCustom comparators can be used for user-defined types.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nIf you need to access or modify elements other than the top, use other containers like set or multiset.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html",
    "href": "DSA Notes/C++STL/map.html",
    "title": "Map",
    "section": "",
    "text": "map&lt;Key, Value&gt; m;\nDeclares an empty map with keys of type Key and values of type Value.\nmap&lt;int, string&gt; m = {{1, ‚Äúone‚Äù}, {2, ‚Äútwo‚Äù}};\nInitializes a map with given key-value pairs.\nmap&lt;int, string&gt; m2(m1);\nCopies all key-value pairs from m1 to m2.\nm[key] = value;\nInserts or updates the value for the given key.\nm.at(key);\nReturns the value associated with key (throws exception if key not found).\nm.insert({key, value});\nInserts a key-value pair (does not overwrite if key exists).\nm.erase(key);\nRemoves the element with the given key.\nm.erase(it);\nRemoves the element pointed to by iterator it.\nm.erase(m.begin(), m.end());\nRemoves all elements in the given range.\nm.find(key);\nReturns an iterator to the key if found, else m.end().\nm.count(key);\nReturns 1 if key is present, 0 otherwise.\nm.size();\nReturns the number of key-value pairs in the map.\nm.empty();\nReturns true if the map is empty.\nm.clear();\nRemoves all elements from the map.\nm.lower_bound(key);\nReturns iterator to the first element not less than key.\nm.upper_bound(key);\nReturns iterator to the first element greater than key.\nm.swap(m2);\nSwaps the contents of m and m2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#important-points-related-to-maps",
    "href": "DSA Notes/C++STL/map.html#important-points-related-to-maps",
    "title": "Map",
    "section": "",
    "text": "map&lt;Key, Value&gt; m;\nDeclares an empty map with keys of type Key and values of type Value.\nmap&lt;int, string&gt; m = {{1, ‚Äúone‚Äù}, {2, ‚Äútwo‚Äù}};\nInitializes a map with given key-value pairs.\nmap&lt;int, string&gt; m2(m1);\nCopies all key-value pairs from m1 to m2.\nm[key] = value;\nInserts or updates the value for the given key.\nm.at(key);\nReturns the value associated with key (throws exception if key not found).\nm.insert({key, value});\nInserts a key-value pair (does not overwrite if key exists).\nm.erase(key);\nRemoves the element with the given key.\nm.erase(it);\nRemoves the element pointed to by iterator it.\nm.erase(m.begin(), m.end());\nRemoves all elements in the given range.\nm.find(key);\nReturns an iterator to the key if found, else m.end().\nm.count(key);\nReturns 1 if key is present, 0 otherwise.\nm.size();\nReturns the number of key-value pairs in the map.\nm.empty();\nReturns true if the map is empty.\nm.clear();\nRemoves all elements from the map.\nm.lower_bound(key);\nReturns iterator to the first element not less than key.\nm.upper_bound(key);\nReturns iterator to the first element greater than key.\nm.swap(m2);\nSwaps the contents of m and m2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#useful-operations",
    "href": "DSA Notes/C++STL/map.html#useful-operations",
    "title": "Map",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nIterating over a map (ascending order of keys):\nfor (auto it = m.begin(); it != m.end(); ++it) { access it-&gt;first, it-&gt;second }\nRange-based for loop:\nfor (auto &p : m) { access p.first, p.second }\nReverse iteration:\nfor (auto it = m.rbegin(); it != m.rend(); ++it) { access it-&gt;first, it-&gt;second }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#notes",
    "href": "DSA Notes/C++STL/map.html#notes",
    "title": "Map",
    "section": "Notes",
    "text": "Notes\n\nmap stores unique keys in sorted order (by default, ascending).\nAll operations (insert, erase, find, count, lower_bound, upper_bound) have O(log N) time complexity.\nUnderlying data structure is usually a balanced BST (like Red-Black Tree).\nKeys are immutable; you cannot modify keys in-place.\nIf you need to store duplicate keys, use multimap.\nIf you need faster operations and do not require ordering, use unordered_map (average O(1) time).\nmap provides random access to values via keys, but not by index.\nIterators remain valid except for erased elements.\nFor custom sorting, provide a comparator as a template argument.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#when-to-use-map",
    "href": "DSA Notes/C++STL/map.html#when-to-use-map",
    "title": "Map",
    "section": "When to Use Map",
    "text": "When to Use Map\n\nWhen you need to associate unique keys with values.\nWhen you need fast search, insertion, and deletion by key (O(log N)).\nWhen order of keys matters.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#additional-points",
    "href": "DSA Notes/C++STL/map.html#additional-points",
    "title": "Map",
    "section": "Additional Points",
    "text": "Additional Points\n\nmap&lt;int, string, greater&lt;int&gt;&gt; m; // Stores keys in descending order.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nmap is useful for frequency counting, associative arrays, and maintaining ordered key-value pairs.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html",
    "href": "DSA Notes/C++STL/list.html",
    "title": "List",
    "section": "",
    "text": "list&lt;T&gt; l;\nDeclares an empty doubly linked list of type T.\nlist&lt;int&gt; l(5, 0);\nInitializes a list of 5 integers, all set to 0.\nlist&lt;char&gt; l2(l1);\nCopies all elements from list l1 to l2.\nlist&lt;int&gt; l = {1, 2, 3};\nInitializes a list with given values.\nl.assign(n, value);\nAssigns n copies of value to the list, replacing current contents.\nl.size();\nReturns the number of elements in the list.\nl.max_size();\nReturns the maximum number of elements the list can hold.\nl.push_back(x);\nAppends element x to the end of the list.\nl.push_front(x);\nInserts element x at the beginning of the list.\nl.emplace_back(args);\nConstructs element in-place at the end.\nl.emplace_front(args);\nConstructs element in-place at the front.\nl.pop_back();\nRemoves the last element.\nl.pop_front();\nRemoves the first element.\nl.insert(it, x);\nInserts element x before iterator it.\nl.erase(it);\nRemoves the element pointed to by iterator it.\nl.erase(it1, it2);\nRemoves elements in the range [it1, it2).\nl.remove(x);\nRemoves all elements equal to x.\nl.clear();\nRemoves all elements from the list.\nl.empty();\nReturns true if the list is empty.\nl.swap(l2);\nSwaps the contents of l and l2.\nl.reverse();\nReverses the order of elements.\nl.sort();\nSorts the list in ascending order.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#important-points-related-to-lists",
    "href": "DSA Notes/C++STL/list.html#important-points-related-to-lists",
    "title": "List",
    "section": "",
    "text": "list&lt;T&gt; l;\nDeclares an empty doubly linked list of type T.\nlist&lt;int&gt; l(5, 0);\nInitializes a list of 5 integers, all set to 0.\nlist&lt;char&gt; l2(l1);\nCopies all elements from list l1 to l2.\nlist&lt;int&gt; l = {1, 2, 3};\nInitializes a list with given values.\nl.assign(n, value);\nAssigns n copies of value to the list, replacing current contents.\nl.size();\nReturns the number of elements in the list.\nl.max_size();\nReturns the maximum number of elements the list can hold.\nl.push_back(x);\nAppends element x to the end of the list.\nl.push_front(x);\nInserts element x at the beginning of the list.\nl.emplace_back(args);\nConstructs element in-place at the end.\nl.emplace_front(args);\nConstructs element in-place at the front.\nl.pop_back();\nRemoves the last element.\nl.pop_front();\nRemoves the first element.\nl.insert(it, x);\nInserts element x before iterator it.\nl.erase(it);\nRemoves the element pointed to by iterator it.\nl.erase(it1, it2);\nRemoves elements in the range [it1, it2).\nl.remove(x);\nRemoves all elements equal to x.\nl.clear();\nRemoves all elements from the list.\nl.empty();\nReturns true if the list is empty.\nl.swap(l2);\nSwaps the contents of l and l2.\nl.reverse();\nReverses the order of elements.\nl.sort();\nSorts the list in ascending order.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#useful-operations",
    "href": "DSA Notes/C++STL/list.html#useful-operations",
    "title": "List",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nIterating over a list:\nfor (auto it = l.begin(); it != l.end(); ++it) { access *it }\nRange-based for loop:\nfor (auto x : l) { access x }\nSplicing (moving elements from one list to another):\nl1.splice(l1.begin(), l2); // Moves all elements from l2 to l1 at the beginning",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#notes",
    "href": "DSA Notes/C++STL/list.html#notes",
    "title": "List",
    "section": "Notes",
    "text": "Notes\n\nlist is a doubly linked list; allows fast insertion and deletion anywhere (O(1) if iterator is known).\nNo random access (no operator[] or at()).\nIterators remain valid even after insertions and deletions (except for erased elements).\nUseful when frequent insertions/deletions are needed at both ends or in the middle.\nMore memory overhead than vector or deque due to pointers.\nNot thread-safe by default.\nFor single linked list, use forward_list.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#when-to-use-list",
    "href": "DSA Notes/C++STL/list.html#when-to-use-list",
    "title": "List",
    "section": "When to Use List",
    "text": "When to Use List\n\nWhen you need frequent insertions and deletions at both ends or in the middle.\nWhen random access is not required.\nWhen stable iterators are important.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#additional-points",
    "href": "DSA Notes/C++STL/list.html#additional-points",
    "title": "List",
    "section": "Additional Points",
    "text": "Additional Points\n\nlist&lt;int, allocator&gt; l; // Custom allocator can be specified.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nUse vector or deque if you need random access or better cache performance.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html",
    "href": "DSA Notes/C++STL/algorithm.html",
    "title": "Algorithm",
    "section": "",
    "text": "STL algorithms are generic functions that operate on containers using iterators.\nMost algorithms are defined in the &lt;algorithm&gt; header.\nWork with all standard containers (vector, deque, list, set, map, etc.) that support iterators.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#important-points-related-to-stl-algorithms",
    "href": "DSA Notes/C++STL/algorithm.html#important-points-related-to-stl-algorithms",
    "title": "Algorithm",
    "section": "",
    "text": "STL algorithms are generic functions that operate on containers using iterators.\nMost algorithms are defined in the &lt;algorithm&gt; header.\nWork with all standard containers (vector, deque, list, set, map, etc.) that support iterators.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#commonly-used-algorithms-with-time-complexities",
    "href": "DSA Notes/C++STL/algorithm.html#commonly-used-algorithms-with-time-complexities",
    "title": "Algorithm",
    "section": "Commonly Used Algorithms (with Time Complexities)",
    "text": "Commonly Used Algorithms (with Time Complexities)\n\nsort(first, last);\nSorts the range [first, last) in ascending order. O(N log N)\nsort(first, last, comp);\nSorts with a custom comparator. O(N log N)\nstable_sort(first, last);\nSorts while preserving the relative order of equal elements. O(N log N)\npartial_sort(first, middle, last);\nSorts the range so that the smallest elements are before middle. O(N log M), M = middle-first\nnth_element(first, nth, last);\nRearranges so that the element at nth is the one that would be in that position in a sorted sequence. O(N)\nreverse(first, last);\nReverses the order of elements in the range. O(N)\nrotate(first, middle, last);\nRotates the elements in the range. O(N)\nfind(first, last, value);\nReturns iterator to the first occurrence of value, or last if not found. O(N)\nfind_if(first, last, pred);\nReturns iterator to the first element satisfying predicate. O(N)\ncount(first, last, value);\nCounts the number of elements equal to value. O(N)\ncount_if(first, last, pred);\nCounts elements satisfying predicate. O(N)\naccumulate(first, last, init);\nReturns the sum of elements in the range (requires &lt;numeric&gt;). O(N)\nmin_element(first, last);\nReturns iterator to the smallest element. O(N)\nmax_element(first, last);\nReturns iterator to the largest element. O(N)\nminmax_element(first, last);\nReturns a pair of iterators to the smallest and largest elements. O(N)\nbinary_search(first, last, value);\nReturns true if value is present (range must be sorted). O(log N)\nlower_bound(first, last, value);\nReturns iterator to the first element not less than value (range must be sorted). O(log N)\nupper_bound(first, last, value);\nReturns iterator to the first element greater than value (range must be sorted). O(log N)\nequal_range(first, last, value);\nReturns a pair of iterators for the subrange of equal elements. O(log N)\nnext_permutation(first, last);\nTransforms the range to the next lexicographically greater permutation. O(N)\nprev_permutation(first, last);\nTransforms the range to the previous permutation. O(N)\nunique(first, last);\nRemoves consecutive duplicates (returns new logical end). O(N)\nremove(first, last, value);\nMoves all elements not equal to value to the front (use with erase for containers). O(N)\nremove_if(first, last, pred);\nRemoves elements satisfying predicate. O(N)\nfill(first, last, value);\nAssigns value to all elements in the range. O(N)\ncopy(first, last, dest);\nCopies elements from [first, last) to dest. O(N)\ncopy_if(first, last, dest, pred);\nCopies elements satisfying predicate. O(N)\nall_of(first, last, pred);\nReturns true if all elements satisfy predicate. O(N)\nany_of(first, last, pred);\nReturns true if any element satisfies predicate. O(N)\nnone_of(first, last, pred);\nReturns true if no elements satisfy predicate. O(N)\nfor_each(first, last, func);\nApplies func to each element in the range. O(N)\nmerge(first1, last1, first2, last2, dest);\nMerges two sorted ranges. O(N1 + N2)\nset_union(first1, last1, first2, last2, dest);\nComputes the union of two sorted ranges. O(N1 + N2)\nset_intersection(first1, last1, first2, last2, dest);\nComputes the intersection of two sorted ranges. O(N1 + N2)\nset_difference(first1, last1, first2, last2, dest);\nComputes the difference of two sorted ranges. O(N1 + N2)\nset_symmetric_difference(first1, last1, first2, last2, dest);\nComputes the symmetric difference of two sorted ranges. O(N1 + N2)",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#example-usage",
    "href": "DSA Notes/C++STL/algorithm.html#example-usage",
    "title": "Algorithm",
    "section": "Example Usage",
    "text": "Example Usage\n\nSorting a vector:\nsort(v.begin(), v.end());\nFinding an element:\nauto it = find(v.begin(), v.end(), x);\nCounting occurrences:\nint cnt = count(v.begin(), v.end(), x);\nSumming elements:\nint sum = accumulate(v.begin(), v.end(), 0);\nBinary search:\nbool found = binary_search(v.begin(), v.end(), x);",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#notes",
    "href": "DSA Notes/C++STL/algorithm.html#notes",
    "title": "Algorithm",
    "section": "Notes",
    "text": "Notes\n\nMost algorithms work on ranges defined by iterators: [first, last).\nMany algorithms are non-modifying (find, count), while others modify the container (sort, reverse, remove).\nSome algorithms require sorted ranges (binary_search, lower_bound, upper_bound, set operations).\nUse lambda functions for custom predicates or comparators.\nAlgorithms do not change the size of containers unless used with erase (e.g., remove-erase idiom).\nFor multi-threaded use, consider thread-safe containers or synchronization.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#when-to-use-stl-algorithms",
    "href": "DSA Notes/C++STL/algorithm.html#when-to-use-stl-algorithms",
    "title": "Algorithm",
    "section": "When to Use STL Algorithms",
    "text": "When to Use STL Algorithms\n\nWhen you need efficient, reusable, and well-tested operations on containers.\nTo avoid writing common routines (sorting, searching, counting, set operations, etc.) manually.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html",
    "href": "DSA Notes/C++STL/queue.html",
    "title": "Queue",
    "section": "",
    "text": "queue&lt;T&gt; q;\nDeclares an empty queue of type T.\nqueue&lt;int&gt; q2(q1);\nCopies all elements from queue q1 to q2.\nqueue&lt;int&gt; q = queue&lt;int&gt;();\nInitializes an empty queue of integers.\nq.size();\nReturns the number of elements in the queue. O(1)\nq.empty();\nReturns true if the queue is empty. O(1)\nq.push(x);\nAdds element x to the back of the queue. O(1)\nq.emplace(args);\nConstructs element in-place at the back (faster than push for objects). O(1)\nq.pop();\nRemoves the front element (does not return it). O(1)\nq.front();\nReturns a reference to the front element. O(1)\nq.back();\nReturns a reference to the last element. O(1)\nq.swap(q2);\nSwaps the contents of q and q2. O(1)\nThere is no direct way to access elements other than the front and back.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#important-points-related-to-queues",
    "href": "DSA Notes/C++STL/queue.html#important-points-related-to-queues",
    "title": "Queue",
    "section": "",
    "text": "queue&lt;T&gt; q;\nDeclares an empty queue of type T.\nqueue&lt;int&gt; q2(q1);\nCopies all elements from queue q1 to q2.\nqueue&lt;int&gt; q = queue&lt;int&gt;();\nInitializes an empty queue of integers.\nq.size();\nReturns the number of elements in the queue. O(1)\nq.empty();\nReturns true if the queue is empty. O(1)\nq.push(x);\nAdds element x to the back of the queue. O(1)\nq.emplace(args);\nConstructs element in-place at the back (faster than push for objects). O(1)\nq.pop();\nRemoves the front element (does not return it). O(1)\nq.front();\nReturns a reference to the front element. O(1)\nq.back();\nReturns a reference to the last element. O(1)\nq.swap(q2);\nSwaps the contents of q and q2. O(1)\nThere is no direct way to access elements other than the front and back.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#notes",
    "href": "DSA Notes/C++STL/queue.html#notes",
    "title": "Queue",
    "section": "Notes",
    "text": "Notes\n\nQueue is a container adapter; by default, it uses deque as the underlying container (can also use list).\nYou can specify the underlying container: queue&lt;int, list&lt;int&gt;&gt; q;\nFollows First-In-First-Out (FIFO) principle.\nNo iterators or random access; you cannot traverse or access elements by index.\nOnly the front and back elements can be accessed.\nTo clear a queue, repeatedly call pop() until empty (no clear() function).\nNot thread-safe by default; use mutexes for multi-threaded scenarios.\nAll main operations (push, pop, front, back, size, empty, swap) are O(1).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#common-applications",
    "href": "DSA Notes/C++STL/queue.html#common-applications",
    "title": "Queue",
    "section": "Common Applications",
    "text": "Common Applications\n\nBreadth-First Search (BFS) in graphs/trees.\nLevel-order traversal in trees.\nTask scheduling and buffering data streams.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#when-to-use-queue",
    "href": "DSA Notes/C++STL/queue.html#when-to-use-queue",
    "title": "Queue",
    "section": "When to Use Queue",
    "text": "When to Use Queue\n\nWhen you need FIFO (First-In-First-Out) access.\nFor problems involving level-order traversal, task scheduling, or buffering.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#when-not-to-use-queue",
    "href": "DSA Notes/C++STL/queue.html#when-not-to-use-queue",
    "title": "Queue",
    "section": "When Not to Use Queue",
    "text": "When Not to Use Queue\n\nIf you need to access or remove elements from the middle, use deque or list.\nIf you need random access, use vector or deque.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  }
]