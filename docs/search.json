[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "DSA",
    "section": "",
    "text": "Hello, I am Nachiket Patil.\nI have decided to take notes while learning DSA.\n\nASCII - 128 Characters\nA to Z = 65 to 90\na to z = 97 to 122\n0 to 9 = 48 to 57"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this site"
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Selection_Sort.html",
    "href": "DSA Notes/Basic Sorting/Selection_Sort.html",
    "title": "Selection Sort",
    "section": "",
    "text": "üìñ Theory\nFind the minimum element from the unsorted part of array and put it at the end of sorted part of array at the begining.\nSteps:\n\nStart from the first element (index 0).\nFind the minimum element in the unsorted part (from current index to end).\nSwap this minimum element with the element at the current index.\nMove to the next index and repeat until the array is sorted.\n\nTime Complexity:\n\nBest: O(n¬≤)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n‚úÖ Code (C++)\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Selection Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Selection_Sort.html#selection-sort",
    "href": "DSA Notes/Basic Sorting/Selection_Sort.html#selection-sort",
    "title": "DSA",
    "section": "",
    "text": "Find the minimum element from the unsorted part of array and put it at the end of sorted part of array at the begining.\nSteps:\n\nStart from the first element (index 0).\nFind the minimum element in the unsorted part (from current index to end).\nSwap this minimum element with the element at the current index.\nMove to the next index and repeat until the array is sorted.\n\nTime Complexity:\n\nBest: O(n¬≤)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n\nvoid selectionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 0; i &lt; n - 1; i++) {\n        int minIdx = i;\n        for (int j = i + 1; j &lt; n; j++) {\n            if (arr[j] &lt; arr[minIdx]) {\n                minIdx = j;\n            }\n        }\n        swap(arr[i], arr[minIdx]);\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Selection Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Quick_Sort.html",
    "href": "DSA Notes/Advanced Sorting/Quick_Sort.html",
    "title": "Quick Sort",
    "section": "",
    "text": "üìñ Theory\nQuick Sort is a divide and conquer sorting algorithm. It works by selecting a ‚Äúpivot‚Äù element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\nSteps:\n\nChoose a pivot element (commonly the last element).\nPartition the array so that all elements less than the pivot are on the left, and all elements greater than the pivot are on the right.\nRecursively apply the above steps to the subarrays on the left and right of the pivot.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n¬≤) (when the smallest or largest element is always chosen as the pivot)\n\nSpace Complexity: O(log n) (due to recursion stack)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\nApplications:\n\nUseful for finding the kth smallest/ largest element (Quickselect algorithm).\n\n\n\n\n‚úÖ Code (C++)\nint partition(vector&lt;int&gt;& arr, int s, int e) {\n  int pivot = s;\n  int count = 0;\n\n  // Count all the numbers which are less the pivot number\n  for (int i = s; i &lt; e + 1; i++) {\n    if (arr[i] &lt; arr[pivot]) {\n      count++;\n    }\n  }\n\n  pivot = s + count;\n  int i = s, j = e;\n\n  while (i &lt; pivot && j &gt; pivot) {\n    if (arr[i] &lt; arr[pivot]) {\n      i++;\n    }\n    else if (arr[j] &gt;= arr[pivot]) {\n      j--;\n    }\n    else {\n      swap(arr[i], arr[j]);\n      i++;\n      j--;\n    }\n  }\n\n  return pivot;\n}\n\nvoid quickSort(vector&lt;int&gt;& arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int p = partition(arr, s, e);\n\n  quickSort(arr, s, p - 1);\n  quickSort(arr, p + 1, e);\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Quick Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Quick_Sort.html#quick-sort",
    "href": "DSA Notes/Advanced Sorting/Quick_Sort.html#quick-sort",
    "title": "DSA",
    "section": "",
    "text": "Quick Sort is a divide and conquer sorting algorithm. It works by selecting a ‚Äúpivot‚Äù element from the array and partitioning the other elements into two subarrays, according to whether they are less than or greater than the pivot. The subarrays are then sorted recursively.\nSteps:\n\nChoose a pivot element (commonly the last element).\nPartition the array so that all elements less than the pivot are on the left, and all elements greater than the pivot are on the right.\nRecursively apply the above steps to the subarrays on the left and right of the pivot.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n¬≤) (when the smallest or largest element is always chosen as the pivot)\n\nSpace Complexity: O(log n) (due to recursion stack)\nStable: ‚ùå No\nIn-place: ‚úÖ Yes\n\n\n\n\nint partition(vector&lt;int&gt;& arr, int s, int e) {\n  int pivot = s;\n  int count = 0;\n\n  // Count all the numbers which are less the pivot number\n  for (int i = s; i &lt; e + 1; i++) {\n    if (arr[i] &lt; arr[pivot]) {\n      count++;\n    }\n  }\n\n  pivot = s + count;\n  int i = s, j = e;\n\n  while (i &lt; pivot && j &gt; pivot) {\n    if (arr[i] &lt; arr[pivot]) {\n      i++;\n    }\n    else if (arr[j] &gt;= arr[pivot]) {\n      j--;\n    }\n    else {\n      swap(arr[i], arr[j]);\n      i++;\n      j--;\n    }\n  }\n}\n\nvoid quickSort(vector&lt;int&gt;& arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int p = partition(arr, s, e);\n\n  quickSort(arr, s, p - 1);\n  quickSort(arr, p + 1, e);\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Quick Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Merge_Sort.html",
    "href": "DSA Notes/Advanced Sorting/Merge_Sort.html",
    "title": "Merge Sort",
    "section": "",
    "text": "üìñ Theory\nMerge Sort is a divide and conquer algorithm. It divides the array into two halves, sorts each half recursively, and then merges the two sorted halves.\nSteps:\n\nDivide the array in two halves (like binary).\nRecursively sort both halves.\nMerge both sorted halves into a single sorted array.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n log n)\n\nSpace Complexity: O(n) (extra space for merging)\nStable: ‚úÖ Yes\nIn-place: ‚ùå No\n\nApplications:\n\nUsed in algorithm that count the number of inversions in array.\n\n\nExtra Things to Know:\n\nMerge Sort is often preferred for sorting linked lists because it does not require random access and can be implemented with O(1) extra space for linked lists.\n\n\n\n\n‚úÖ Code (C++)\nvoid mergeSort(vector &lt;int&gt; &arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int mid = s + (e - s) / 2;\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n\n  merge(arr, s, e);\n}\n\nvoid merge(vector &lt;int&gt; &arr, int s, int e) {\n  int mid = s + (e - s) / 2;\n  int len1 = mid - s + 1;\n  int len2 = e - mid;\n\n  int *first = new int[len1];\n  int *second = new int[len2];\n\n  int main_arr_ind = s;\n  for (int i = 0; i &lt; len1; i++) {\n    first[i] = arr[main_arr_ind++];\n  }\n\n  main_arr_ind = mid + 1;\n  for (int i = 0; i &lt; len2; i++) {\n    second[i] = arr[main_arr_ind++];\n  }\n\n  int ind1 = 0, ind2 = 0;\n  main_arr_ind = s;\n\n  while (ind1 &lt; len1 && ind2 &lt; len2) {\n    if (first[ind1] &lt; second[ind2]) {\n      arr[main_arr_ind++] = first[ind1++];\n    }\n    else {\n      arr[main_arr_ind++] = second[ind2++];\n    }\n  }\n\n  while (ind1 &lt; len1) {\n    arr[main_arr_ind++] = first[ind1++];\n  }\n\n  while (ind2 &lt; len2) {\n    arr[main_arr_ind++] = second[ind2++];\n  }\n\n  delete []first;\n  delete []second;\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Merge Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Advanced Sorting/Merge_Sort.html#merge-sort",
    "href": "DSA Notes/Advanced Sorting/Merge_Sort.html#merge-sort",
    "title": "DSA",
    "section": "",
    "text": "Merge Sort is a divide and conquer algorithm. It divides the array into two halves, sorts each half recursively, and then merges the two sorted halves.\nSteps:\n\nDivide the array in two halves (like binary).\nRecursively sort both halves.\nMerge both sorted halves into a single sorted array.\n\nTime Complexity:\n\nBest: O(n log n)\nAverage: O(n log n)\nWorst: O(n log n)\n\nSpace Complexity: O(n) (extra space for merging)\nStable: ‚úÖ Yes\nIn-place: ‚ùå No\n\n\n\n\nvoid mergeSort(vector &lt;int&gt; &arr, int s, int e) {\n  if (s &gt;= e) {\n    return;\n  }\n\n  int mid = s + (e - s) / 2;\n\n  mergeSort(arr, s, mid);\n  mergeSort(arr, mid + 1, e);\n\n  merge(arr, s, e);\n}\n\nvoid merge(&lt;vector&gt; &arr, int s, int e) {\n  int mid = s + (e - s) / 2;\n  int len1 = mid - s + 1;\n  int len2 = e - mid;\n\n  int *first = new int[len1];\n  int *second = new int[len2];\n\n  int main_arr_ind = s;\n  for (int i = 0; i &lt; len1; i++) {\n    first[i] = arr[main_arr_ind++];\n  }\n\n  main_arr_ind = mid + 1;\n  for (int i = 0; i &lt; len2; i++) {\n    second[i] = arr[main_arr_ind++];\n  }\n\n  int ind1 = 0, ind2 = 0;\n  main_arr_ind = s;\n\n  while (ind1 &lt; len1 && ind2 &lt; len2) {\n    if (arr[ind1] &lt; arr[ind2]) {\n      arr[main_arr_ind++] = arr[ind1++];\n    }\n    else {\n      arr[main_arr_ind++] = arr[ind2++];\n    }\n  }\n\n  while (ind1 &lt; len1) {\n    arr[main_arr_ind++] = arr[ind1++];\n  }\n\n  while (ind2 &lt; len2) {\n    arr[main_arr_ind++] = arr[ind2++];\n  }\n\n  delete []first;\n  delete []second;\n}",
    "crumbs": [
      "Home",
      "Advanced Sorting",
      "Merge Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Bubble_Sort.html",
    "href": "DSA Notes/Basic Sorting/Bubble_Sort.html",
    "title": "Bubble Sort",
    "section": "",
    "text": "üìñ Theory\nCompare adjacent elements, and move the large element to right in each loop.\n\nSteps:\n\nStart from the first element.\nCompare each pair of adjacent elements.\nIf the left element is greater than the right, swap them.\nRepeat for all elements, reducing the range by one each time (since the last element is sorted after each pass).\nStop if no swaps are made in a pass (array is sorted).\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n‚úÖ Code (C++)\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i &lt; n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;  // Optimization\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Bubble Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Bubble_Sort.html#bubble-sort",
    "href": "DSA Notes/Basic Sorting/Bubble_Sort.html#bubble-sort",
    "title": "DSA",
    "section": "",
    "text": "Compare adjacent elements, and move the large element to right in each loop.\n\nSteps:\n\nStart from the first element.\nCompare each pair of adjacent elements.\nIf the left element is greater than the right, swap them.\nRepeat for all elements, reducing the range by one each time (since the last element is sorted after each pass).\nStop if no swaps are made in a pass (array is sorted).\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n\nvoid bubbleSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    bool swapped;\n    for (int i = 0; i &lt; n - 1; i++) {\n        swapped = false;\n        for (int j = 0; j &lt; n - i - 1; j++) {\n            if (arr[j] &gt; arr[j + 1]) {\n                swap(arr[j], arr[j + 1]);\n                swapped = true;\n            }\n        }\n        if (!swapped) break;  // Optimization\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Bubble Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Insertion_Sort.html",
    "href": "DSA Notes/Basic Sorting/Insertion_Sort.html",
    "title": "Insertion Sort",
    "section": "",
    "text": "üìñ Theory\nTake the first element from unsorted part, and put it at its correct position in sorted part.\n\nSteps:\n\nStart from the second element (index 1).\nCompare it with elements before it.\nShift larger elements one position to the right.\nInsert the current element into the correct position.\nRepeat for all elements.\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n‚úÖ Code (C++)\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        // Move elements greater than key to one position ahead\n        while (j &gt;= 0 && arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Insertion Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Basic Sorting/Insertion_Sort.html#insertion-sort",
    "href": "DSA Notes/Basic Sorting/Insertion_Sort.html#insertion-sort",
    "title": "DSA",
    "section": "",
    "text": "Take the first element from unsorted part, and put it at its correct position in sorted part.\n\nSteps:\n\nStart from the second element (index 1).\nCompare it with elements before it.\nShift larger elements one position to the right.\nInsert the current element into the correct position.\nRepeat for all elements.\n\nTime Complexity:\n\nBest: O(n) (when already sorted)\nAverage: O(n¬≤)\nWorst: O(n¬≤)\n\nSpace Complexity: O(1)\n\nStable: ‚úÖ Yes\nIn-place: ‚úÖ Yes\n\n\n\n\n\nvoid insertionSort(vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    for (int i = 1; i &lt; n; i++) {\n        int key = arr[i];\n        int j = i - 1;\n\n        // Move elements greater than key to one position ahead\n        while (j &gt;= 0 && arr[j] &gt; key) {\n            arr[j + 1] = arr[j];\n            j--;\n        }\n\n        arr[j + 1] = key;\n    }\n}",
    "crumbs": [
      "Home",
      "Basic Sorting",
      "Insertion Sort"
    ]
  },
  {
    "objectID": "DSA Notes/Binary_Search.html",
    "href": "DSA Notes/Binary_Search.html",
    "title": "Binary Search",
    "section": "",
    "text": "üìñ Theory\nBinary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\n\n\n‚úÖ Code (C++)\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n    }\n    return -1; // Not found\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary_Search.html#binary-search",
    "href": "DSA Notes/Binary_Search.html#binary-search",
    "title": "DSA",
    "section": "",
    "text": "Binary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\n\n\n\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n    }\n    return -1; // Not found\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/Binary_Search.html",
    "href": "DSA Notes/Binary Search/Binary_Search.html",
    "title": "Binary Search",
    "section": "",
    "text": "üìñ Theory\nBinary Search is an efficient algorithm to find the position of a target value within a sorted array.\nIt repeatedly divides the search interval in half, comparing the target with the middle element.\n\nNote: Only works when array is sorted.\n\nSteps:\n\nSet s = 0, e = n - 1.\nWhile s &lt;= e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] == target, return mid.\nIf arr[mid] &lt; target, set s = mid + 1.\nIf arr[mid] &gt; target, set e = mid - 1.\n\nIf not found, return -1.\n\nTime Complexity:\n\nBest: O(1) (if the middle is the target)\nAverage: O(log n)\nWorst: O(log n)\n\nSpace Complexity: O(1)\n\nApplications:\n\nUsed in searching in sorted arrays.\nLower/upper bound problems.\nFinding insert position in sorted data.\n\n\nExtra Things to Know:\n\nSome times we face issue of index out of range. In such cases try taking s = 1 and e = n - 2. And ensure conditions on 0 and n - 1 before applying the while loop.\n\n\n\n\n‚úÖ Code (C++)\nint binarySearch(const vector&lt;int&gt;& arr, int target) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt;= e) {\n        if (arr[mid] == target) {\n            return mid;\n        }\n        else if (arr[mid] &lt; target) {\n            s = mid + 1;\n        }\n        else {\n            e = mid - 1;\n        }\n        mid = s + (e - s) / 2;\n    }\n    return -1; // Not found\n}\nRecursive Verison\nint binarySearchRecursive(const vector&lt;int&gt;& arr, int s, int e, int target) {\n    if (s &gt; e) {\n        return -1;\n    }\n    int mid = s + (e - s) / 2;\n    if (arr[mid] == target) {\n        return mid;\n    }\n    else if (arr[mid] &lt; target) {\n        return binarySearchRecursive(arr, mid + 1, e, target);\n    }\n    else {\n        return binarySearchRecursive(arr, s, mid - 1, target);\n    }\n}",
    "crumbs": [
      "Home",
      "Binary Search",
      "Binary Search"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/BS_rotated_no_dupli.html",
    "href": "DSA Notes/Binary Search/BS_rotated_no_dupli.html",
    "title": "Binary Search in Rotated Sorted Array (No Duplicates)",
    "section": "",
    "text": "üìñ Theory\nThe array will be like {5, 6, 7, 8, 1, 2, 3}, here we have to find target element with the help of Binary Search.\n\nSteps:\n\nTo find the pivot index (index of the smallest element), set s = 0, e = n - 1.\nWhile s &lt; e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] &gt;= arr[0], set s = mid + 1.\nElse set e = mid.\n\nAfter the loop, s will be the index of the smallest element (pivot).\nCompare the target element with arr[0]:\n\nIf target &gt;= arr[0], apply binary search on the range [0, pivot - 1].\nElse, apply binary search on the range [pivot, n - 1].\n\n\n\n\n\n‚úÖ Code (C++)\nint pivot(vector &lt;int&gt; &arr) {\n    int s = 0, e = arr.size() - 1;\n\n    // Non rotated sorted array\n    if (arr[s] &lt;= arr[e]) {\n        return 0;\n    }\n\n    int mid = s + (e - s) / 2;\n    while (s &lt; e) {\n        if (arr[mid] &gt;= arr[0]) {\n            s = mid + 1;\n        }\n        else {\n            e = mid;\n        }\n        mid = s + (e - s) / 2;\n    }\n\n    return s;\n}\n\n// Now apply Binary Search",
    "crumbs": [
      "Home",
      "Binary Search",
      "BS in Rotated Array (No Duplicates)"
    ]
  },
  {
    "objectID": "DSA Notes/Binary Search/BS_rotated_dupli.html",
    "href": "DSA Notes/Binary Search/BS_rotated_dupli.html",
    "title": "Binary Search in Rotated Sorted Array (With Duplicates)",
    "section": "",
    "text": "üìñ Theory\nThe array will be like {3, 3, 5, 6, 7, 8, 8, 8, 1, 2, 3}, here we have to find target element with the help of Binary Search.\n\nSteps:\n\nTo find the pivot index (index of the smallest element), set s = 0, e = n - 1.\nWhile s &lt; e:\n\nFind mid = (s + e) / 2.\nIf arr[mid] &gt; arr[e], set s = mid + 1.\nElse if arr[mid] &lt; arr[e], set e = mid.\nElse (arr[mid] == arr[e]), decrement e by 1.\n\nAfter the loop, s will be the index of the smallest element (pivot).\nCompare the target element with arr[0]:\n\nIf target &gt;= arr[0], apply binary search on the range [0, pivot - 1].\nElse, apply binary search on the range [pivot, n - 1].\n\n\n\n\n\n‚úÖ Code (C++)\nint pivot(vector &lt;int&gt; &arr) {\n    int s = 0, e = arr.size() - 1;\n    int mid = s + (e - s) / 2;\n    while (s &lt; e) {\n        if (arr[mid] &gt; arr[e]) {\n            s = mid + 1;        \n        }\n        else if (arr[mid] &lt; arr[e]) {\n            e = mid;             \n        }\n        else {\n            e--;                  \n        }\n        mid = s + (e - s) / 2;\n    }\n\n    return s;\n}\n\n// Now apply Binary Search",
    "crumbs": [
      "Home",
      "Binary Search",
      "BS in Rotated Array (Duplicates)"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html",
    "href": "DSA Notes/Recursion/recursion.html",
    "title": "Recursion",
    "section": "",
    "text": "üìñ Theory\nRecursion is a programming technique where a function calls itself to solve smaller instances of a problem.\n\nWhy Use Recursion?\n\nSimplifies code for problems that have a natural recursive structure (e.g., trees, graphs, divide & conquer).\nMakes code easier to read for certain problems.\n\n\nKey Concepts\n\nBase Case: The condition under which the recursion ends. Prevents infinite recursion.\nProcessing: Where you perform some opeartions before next recursive call.\nRecursive Case: The part where the function calls itself with a smaller or simpler input.\n\n\nAnatomy of a Recursive Function\nvoid recursiveFunction(parameters) {\n    if (base_case_condition) {\n        // Handle base case\n        return;\n    }\n\n    // Processing\n\n    // Recursive call(s)\n    recursiveFunction(smaller_problem);\n}\n\nExample 1: Factorial\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}\nExample 2: Fibonacci Numbers\nint fibonacci(int n) {\n    if (n &lt;= 1) return n; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}\n\nHow Recursion Works (Call Stack)\n\nEach recursive call adds a new frame to the call stack.\nWhen a base case is reached, the stack unwinds.\n\nCommon Mistakes\n\nMissing base case: Leads to infinite recursion (stack overflow).\nIncorrect base case: May cause wrong results.\nNot reducing the problem: The recursive call must progress toward the base case.\n\nWhen to Use Recursion\n\nProblems that can be broken into similar subproblems (e.g., tree traversals, searching, sorting).\nWhen iterative solutions are complex or less readable.\n\n\nAdvanced Recursion\n\nBacktracking: Used for problems like permutations, combinations, N-Queens, Sudoku.\nDivide and Conquer: Algorithms like Merge Sort, Quick Sort use recursion to divide the problem.\nDynamic Programming (Memoization): Optimize recursive solutions by storing results of subproblems.\n\n\nExample: Backtracking (N-Queens)\nvoid solveNQueens(int row, vector&lt;string&gt;& board, vector&lt;vector&lt;string&gt;&gt;& solutions) {\n    if (row == board.size()) {\n        solutions.push_back(board);\n        return;\n    }\n    for (int col = 0; col &lt; board.size(); col++) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueens(row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}\n\nTips to Master Recursion\n\nDraw the recursion tree for small inputs.\nTrace the call stack step by step.\nStart with the base case and build up.\n\n\nRecursion vs Iteration\n\n\n\nRecursion\nIteration\n\n\n\n\nElegant for some problems\nUsually more efficient\n\n\nUses call stack\nUses loop variables\n\n\nCan be less efficient\nOften faster and uses less memory",
    "crumbs": [
      "Home",
      "Recursion",
      "Recursion"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#what-is-recursion",
    "href": "DSA Notes/Recursion/recursion.html#what-is-recursion",
    "title": "Recursion",
    "section": "",
    "text": "Recursion is a programming technique where a function calls itself to solve smaller instances of a problem."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#why-use-recursion",
    "href": "DSA Notes/Recursion/recursion.html#why-use-recursion",
    "title": "Recursion",
    "section": "Why Use Recursion?",
    "text": "Why Use Recursion?\n\nSimplifies code for problems that have a natural recursive structure (e.g., trees, graphs, divide & conquer).\nMakes code easier to read for certain problems."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#key-concepts",
    "href": "DSA Notes/Recursion/recursion.html#key-concepts",
    "title": "Recursion",
    "section": "Key Concepts",
    "text": "Key Concepts\n\n1. Base Case\nThe condition under which the recursion ends. Prevents infinite recursion.\n\n\n2. Recursive Case\nThe part where the function calls itself with a smaller or simpler input."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#anatomy-of-a-recursive-function",
    "href": "DSA Notes/Recursion/recursion.html#anatomy-of-a-recursive-function",
    "title": "Recursion",
    "section": "Anatomy of a Recursive Function",
    "text": "Anatomy of a Recursive Function\nvoid recursiveFunction(parameters) {\n    if (base_case_condition) {\n        // Handle base case\n        return;\n    }\n    // Recursive call(s)\n    recursiveFunction(smaller_problem);\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-1-factorial",
    "href": "DSA Notes/Recursion/recursion.html#example-1-factorial",
    "title": "Recursion",
    "section": "Example 1: Factorial",
    "text": "Example 1: Factorial\nint factorial(int n) {\n    if (n == 0) return 1; // Base case\n    return n * factorial(n - 1); // Recursive case\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-2-fibonacci-numbers",
    "href": "DSA Notes/Recursion/recursion.html#example-2-fibonacci-numbers",
    "title": "Recursion",
    "section": "Example 2: Fibonacci Numbers",
    "text": "Example 2: Fibonacci Numbers\nint fibonacci(int n) {\n    if (n &lt;= 1) return n; // Base case\n    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#how-recursion-works-call-stack",
    "href": "DSA Notes/Recursion/recursion.html#how-recursion-works-call-stack",
    "title": "Recursion",
    "section": "How Recursion Works (Call Stack)",
    "text": "How Recursion Works (Call Stack)\n\nEach recursive call adds a new frame to the call stack.\nWhen a base case is reached, the stack unwinds."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#common-mistakes",
    "href": "DSA Notes/Recursion/recursion.html#common-mistakes",
    "title": "Recursion",
    "section": "Common Mistakes",
    "text": "Common Mistakes\n\nMissing base case: Leads to infinite recursion (stack overflow).\nIncorrect base case: May cause wrong results.\nNot reducing the problem: The recursive call must progress toward the base case."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#when-to-use-recursion",
    "href": "DSA Notes/Recursion/recursion.html#when-to-use-recursion",
    "title": "Recursion",
    "section": "When to Use Recursion",
    "text": "When to Use Recursion\n\nProblems that can be broken into similar subproblems (e.g., tree traversals, searching, sorting).\nWhen iterative solutions are complex or less readable."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#practice-problems",
    "href": "DSA Notes/Recursion/recursion.html#practice-problems",
    "title": "Recursion",
    "section": "Practice Problems",
    "text": "Practice Problems\n\nSum of Array: Write a recursive function to sum all elements of an array.\nReverse a String: Recursively reverse a string.\nPower Function: Compute a^b recursively.\nCheck Palindrome: Check if a string is a palindrome using recursion.\nTower of Hanoi: Classic recursion puzzle."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#advanced-recursion",
    "href": "DSA Notes/Recursion/recursion.html#advanced-recursion",
    "title": "Recursion",
    "section": "Advanced Recursion",
    "text": "Advanced Recursion\n\n1. Backtracking\nUsed for problems like permutations, combinations, N-Queens, Sudoku.\n\n\n2. Divide and Conquer\nAlgorithms like Merge Sort, Quick Sort use recursion to divide the problem.\n\n\n3. Dynamic Programming (Memoization)\nOptimize recursive solutions by storing results of subproblems."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#example-backtracking-n-queens",
    "href": "DSA Notes/Recursion/recursion.html#example-backtracking-n-queens",
    "title": "Recursion",
    "section": "Example: Backtracking (N-Queens)",
    "text": "Example: Backtracking (N-Queens)\nvoid solveNQueens(int row, vector&lt;string&gt;& board, vector&lt;vector&lt;string&gt;&gt;& solutions) {\n    if (row == board.size()) {\n        solutions.push_back(board);\n        return;\n    }\n    for (int col = 0; col &lt; board.size(); col++) {\n        if (isSafe(board, row, col)) {\n            board[row][col] = 'Q';\n            solveNQueens(row + 1, board, solutions);\n            board[row][col] = '.'; // Backtrack\n        }\n    }\n}"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#tips-to-master-recursion",
    "href": "DSA Notes/Recursion/recursion.html#tips-to-master-recursion",
    "title": "Recursion",
    "section": "Tips to Master Recursion",
    "text": "Tips to Master Recursion\n\nDraw the recursion tree for small inputs.\nTrace the call stack step by step.\nStart with the base case and build up.\nPractice! The more problems you solve, the better you‚Äôll understand recursion."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#recursion-vs-iteration",
    "href": "DSA Notes/Recursion/recursion.html#recursion-vs-iteration",
    "title": "Recursion",
    "section": "Recursion vs Iteration",
    "text": "Recursion vs Iteration\n\n\n\nRecursion\nIteration\n\n\n\n\nElegant for some problems\nUsually more efficient\n\n\nUses call stack\nUses loop variables\n\n\nCan be less efficient\nOften faster and uses less memory"
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#summary",
    "href": "DSA Notes/Recursion/recursion.html#summary",
    "title": "Recursion",
    "section": "Summary",
    "text": "Summary\n\nRecursion is a powerful tool for solving complex problems.\nAlways define a clear base case.\nPractice with classic problems to build intuition."
  },
  {
    "objectID": "DSA Notes/Recursion/recursion.html#further-reading",
    "href": "DSA Notes/Recursion/recursion.html#further-reading",
    "title": "Recursion",
    "section": "Further Reading",
    "text": "Further Reading\n\nRecursion (GeeksforGeeks)\nVisualgo Recursion Visualizer\nLeetCode Recursion Problems"
  },
  {
    "objectID": "DSA Notes/Recursion/finding_power_set.html",
    "href": "DSA Notes/Recursion/finding_power_set.html",
    "title": "Finding the Power Set",
    "section": "",
    "text": "üìñ Theory\nYou will be given an array like {1, 2, 3} or a string ‚Äúabc‚Äù. You need to find out all possible subsets, e.g.:\n\nFor {1, 2, 3}: {[], [1], [2], [1,2], [3], [1,3], [2,3], [1,2,3]}\nFor ‚Äúabc‚Äù: {‚Äú‚Äú,‚Äùa‚Äù, ‚Äúab‚Äù, ‚Äúabc‚Äù, ‚Äúac‚Äù, ‚Äúb‚Äù, ‚Äúbc‚Äù, ‚Äúc‚Äù}\n\n\nUsing Recursion\n\nAt each step, decide to include or exclude the current element.\nBase Case: If i &gt;= arr.size(), print or store the current subset.\n\n  Base Case:\n    i &gt;= arr.size();\n\n   i        output                            \n  {1, 2, 3} , {}\n   |                         i      output\n   |-- |-- include 1 --&gt; {1, 2, 3} , {1,}\n       |                     |                        i    output              \n       |                     |-- include 2 --&gt; {1, 2, 3} , {1, 2}\n       |                     |                        i    output\n       |                     |-- exclude 2 --&gt; {1, 2, 3} , {1,}\n       |\n       |                     i      output\n       |-- exclude 1 --&gt; {1, 2, 3} , {}\n       |                     |                        i    output              \n       |                     |-- include 2 --&gt; {1, 2, 3} , {2}\n       |                     |                        i    output\n       |                     |-- exclude 2 --&gt; {1, 2, 3} , {}\n\nLike wise include and exclude the next numbers recursively.",
    "crumbs": [
      "Home",
      "Recursion",
      "Finding the Power Set"
    ]
  },
  {
    "objectID": "DSA Notes/Recursion/pairing_two_or_multiple_sets.html",
    "href": "DSA Notes/Recursion/pairing_two_or_multiple_sets.html",
    "title": "Pairing of Two or Multiple Arrays",
    "section": "",
    "text": "üìñ Theory\nWe will be given with [[a, b, c], [x, y, z]] and need to pair them in all possible ways as ax, ay, az, bx and so on.\n\nUsing Recursion\n\nAt each step (for each array), pick one element from the current array.\nMove to the next array and repeat the process, building up the current combination.\nBase Case: If you have picked one element from each array (i.e., reached the end), print or store the current combination.\nThis approach generates all possible pairings (or tuples) by exploring every choice at each level.\n\n  Base Case:\n    i &gt;= arr.size();\n\n  (   i   )             output\n  [a, b, c] & [x, y, z] , {}\n      |               (   i   )  output              (   i   )  output              (   i   )  output\n      |-- [a, b, c] & [x, y, z] , {a,} & [a, b, c] & [x, y, z] , {b,} & [a, b, c] & [x, y, z] , {c,}\n                          |\n                          |                       &lt; i output                       &lt; i output                       &lt; i output\n                          |-- [a, b, c] & [x, y, z] , {a, x} & [a, b, c] & [x, y, z] , {a, y} & [a, b, c] & [x, y, z] , {a, z}  \nLike wise bx, by, bz and cx, cy, cz.",
    "crumbs": [
      "Home",
      "Recursion",
      "Pairing of Two or Multiple Arrays"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html",
    "href": "DSA Notes/C++STL/vector.html",
    "title": "Vector",
    "section": "",
    "text": "vector&lt;T&gt; v;\nDeclares an empty vector of type T.\nvector&lt;int&gt; v(10, 0);\nInitializes a vector of 10 integers, all set to 0.\nvector&lt;char&gt; v2(v1);\nCopies all elements from vector v1 to v2.\nvector&lt;int&gt; v = {1, 2, 3};\nInitializes a vector with given values.\nv.assign(n, value);\nAssigns n copies of value to the vector, replacing current contents.\nv.size();\nReturns the number of elements in the vector.\nv.capacity();\nReturns the size of the storage space currently allocated (can be greater than or equal to size).\nv.max_size();\nReturns the maximum number of elements the vector can hold.\nv.resize(n);\nChanges the size of the vector to n.¬†If n is greater, new elements are default-initialized.\nv.push_back(x);\nAppends element x to the end of the vector.\nv.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nv.at(i);\nReturns the element at index i (with bounds checking).\nv[i];\nReturns the element at index i (no bounds checking).\nv.front();\nReturns the first element.\nv.back();\nReturns the last element.\nv.pop_back();\nRemoves the last element.\nv.clear();\nRemoves all elements. Size becomes 0, but capacity (allocated memory) remains unchanged.\nv.empty();\nReturns true if the vector is empty.\nv.swap(v2);\nSwaps the contents of v and v2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#important-points-related-to-vectors",
    "href": "DSA Notes/C++STL/vector.html#important-points-related-to-vectors",
    "title": "Vector",
    "section": "",
    "text": "vector&lt;T&gt; v;\nDeclares an empty vector of type T.\nvector&lt;int&gt; v(10, 0);\nInitializes a vector of 10 integers, all set to 0.\nvector&lt;char&gt; v2(v1);\nCopies all elements from vector v1 to v2.\nvector&lt;int&gt; v = {1, 2, 3};\nInitializes a vector with given values.\nv.assign(n, value);\nAssigns n copies of value to the vector, replacing current contents.\nv.size();\nReturns the number of elements in the vector.\nv.capacity();\nReturns the size of the storage space currently allocated (can be greater than or equal to size).\nv.max_size();\nReturns the maximum number of elements the vector can hold.\nv.resize(n);\nChanges the size of the vector to n.¬†If n is greater, new elements are default-initialized.\nv.push_back(x);\nAppends element x to the end of the vector.\nv.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nv.at(i);\nReturns the element at index i (with bounds checking).\nv[i];\nReturns the element at index i (no bounds checking).\nv.front();\nReturns the first element.\nv.back();\nReturns the last element.\nv.pop_back();\nRemoves the last element.\nv.clear();\nRemoves all elements. Size becomes 0, but capacity (allocated memory) remains unchanged.\nv.empty();\nReturns true if the vector is empty.\nv.swap(v2);\nSwaps the contents of v and v2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#useful-operations",
    "href": "DSA Notes/C++STL/vector.html#useful-operations",
    "title": "Vector",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nsort(v.begin(), v.end());\nSorts the vector in ascending order. Time: O(N log N).\nreverse(v.begin(), v.end());\nReverses the order of elements.\nv.erase(v.begin() + i);\nRemoves the element at index i.\nv.erase(v.begin() + i, v.begin() + j);\nRemoves elements from index i up to (but not including) index j. Time: O(N).\nv.insert(v.begin() + i, x);\nInserts element x at index i.\nv.insert(v.begin() + i, n, x);\nInserts n copies of x at index i.\nv.insert(v.end(), {a, b, c});\nInserts multiple elements at the end.\nfind(v.begin(), v.end(), x);\nReturns an iterator to the first occurrence of x (or v.end() if not found). Time: O(N).\nlower_bound(v.begin(), v.end(), x);\nReturns iterator to the first element not less than x (vector must be sorted).\nupper_bound(v.begin(), v.end(), x);\nReturns iterator to the first element greater than x (vector must be sorted).\naccumulate(v.begin(), v.end(), 0);\nReturns the sum of all elements (requires #include &lt;numeric&gt;).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#notes",
    "href": "DSA Notes/C++STL/vector.html#notes",
    "title": "Vector",
    "section": "Notes",
    "text": "Notes\n\nVectors are dynamic arrays; they resize automatically as elements are added or removed.\nMemory is contiguous, so vectors can be passed to C-style functions expecting arrays.\nAccessing elements out of bounds with v[i] is undefined behavior; use v.at(i) for safety.\nIterators become invalid after insertions or deletions (except at the end).\nTo shrink capacity to fit size, use: v.shrink_to_fit();\nInserting or erasing elements at the end is fast (amortized O(1)), but at other positions it is O(N).\nUse reserve(n) to pre-allocate memory if the number of elements is known in advance to avoid multiple reallocations.\nVectors are not thread-safe by default; use mutexes for multi-threaded scenarios.\nSuitable for situations where you need fast random access and frequent insertions/removals at the end.\nIf you need to insert or remove elements frequently at the beginning or middle, consider using deque or list.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/vector.html#iterating-over-a-vector",
    "href": "DSA Notes/C++STL/vector.html#iterating-over-a-vector",
    "title": "Vector",
    "section": "Iterating Over a Vector",
    "text": "Iterating Over a Vector\n\nUsing index:\nfor (int i = 0; i &lt; v.size(); i++) { access v[i] }\nUsing iterator:\nfor (auto it = v.begin(); it != v.end(); ++it) { access *it }\nUsing range-based for loop:\nfor (auto x : v) { access x }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Vector"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html",
    "href": "DSA Notes/C++STL/deque.html",
    "title": "Deque",
    "section": "",
    "text": "deque&lt;T&gt; d;\nDeclares an empty deque of type T.\ndeque&lt;int&gt; d(10, 0);\nInitializes a deque of 10 integers, all set to 0.\ndeque&lt;char&gt; d2(d1);\nCopies all elements from deque d1 to d2.\ndeque&lt;int&gt; d = {1, 2, 3};\nInitializes a deque with given values.\nd.assign(n, value);\nAssigns n copies of value to the deque, replacing current contents.\nd.size();\nReturns the number of elements in the deque.\nd.max_size();\nReturns the maximum number of elements the deque can hold.\nd.resize(n);\nChanges the size of the deque to n.¬†If n is greater, new elements are default-initialized.\nd.push_back(x);\nAppends element x to the end of the deque.\nd.push_front(x);\nInserts element x at the beginning of the deque.\nd.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nd.emplace_front(args);\nConstructs element in-place at the front.\nd.at(i);\nReturns the element at index i (with bounds checking).\nd[i];\nReturns the element at index i (no bounds checking).\nd.front();\nReturns the first element.\nd.back();\nReturns the last element.\nd.pop_back();\nRemoves the last element.\nd.pop_front();\nRemoves the first element.\nd.clear();\nRemoves all elements. Size becomes 0.\nd.empty();\nReturns true if the deque is empty.\nd.swap(d2);\nSwaps the contents of d and d2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#important-points-related-to-deques",
    "href": "DSA Notes/C++STL/deque.html#important-points-related-to-deques",
    "title": "Deque",
    "section": "",
    "text": "deque&lt;T&gt; d;\nDeclares an empty deque of type T.\ndeque&lt;int&gt; d(10, 0);\nInitializes a deque of 10 integers, all set to 0.\ndeque&lt;char&gt; d2(d1);\nCopies all elements from deque d1 to d2.\ndeque&lt;int&gt; d = {1, 2, 3};\nInitializes a deque with given values.\nd.assign(n, value);\nAssigns n copies of value to the deque, replacing current contents.\nd.size();\nReturns the number of elements in the deque.\nd.max_size();\nReturns the maximum number of elements the deque can hold.\nd.resize(n);\nChanges the size of the deque to n.¬†If n is greater, new elements are default-initialized.\nd.push_back(x);\nAppends element x to the end of the deque.\nd.push_front(x);\nInserts element x at the beginning of the deque.\nd.emplace_back(args);\nConstructs element in-place at the end (faster than push_back for objects).\nd.emplace_front(args);\nConstructs element in-place at the front.\nd.at(i);\nReturns the element at index i (with bounds checking).\nd[i];\nReturns the element at index i (no bounds checking).\nd.front();\nReturns the first element.\nd.back();\nReturns the last element.\nd.pop_back();\nRemoves the last element.\nd.pop_front();\nRemoves the first element.\nd.clear();\nRemoves all elements. Size becomes 0.\nd.empty();\nReturns true if the deque is empty.\nd.swap(d2);\nSwaps the contents of d and d2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#useful-operations",
    "href": "DSA Notes/C++STL/deque.html#useful-operations",
    "title": "Deque",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nsort(d.begin(), d.end());\nSorts the deque in ascending order. Time: O(N log N).\nreverse(d.begin(), d.end());\nReverses the order of elements.\nd.erase(d.begin() + i);\nRemoves the element at index i.\nd.erase(d.begin() + i, d.begin() + j);\nRemoves elements from index i up to (but not including) index j.\nd.insert(d.begin() + i, x);\nInserts element x at index i.\nd.insert(d.begin() + i, n, x);\nInserts n copies of x at index i.\nd.insert(d.end(), {a, b, c});\nInserts multiple elements at the end.\nfind(d.begin(), d.end(), x);\nReturns an iterator to the first occurrence of x (or d.end() if not found).\nlower_bound(d.begin(), d.end(), x);\nReturns iterator to the first element not less than x (deque must be sorted).\nupper_bound(d.begin(), d.end(), x);\nReturns iterator to the first element greater than x (deque must be sorted).\naccumulate(d.begin(), d.end(), 0);\nReturns the sum of all elements (requires #include &lt;numeric&gt;).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#iterating-over-a-deque",
    "href": "DSA Notes/C++STL/deque.html#iterating-over-a-deque",
    "title": "Deque",
    "section": "Iterating Over a Deque",
    "text": "Iterating Over a Deque\n\nUsing index:\nfor (int i = 0; i &lt; d.size(); i++) { access d[i] }\nUsing iterator:\nfor (auto it = d.begin(); it != d.end(); ++it) { access *it }\nUsing range-based for loop:\nfor (auto x : d) { access x }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#notes",
    "href": "DSA Notes/C++STL/deque.html#notes",
    "title": "Deque",
    "section": "Notes",
    "text": "Notes\n\nDeques (double-ended queues) allow fast insertion and deletion at both the front and back (O(1) time).\nRandom access to elements is O(1), similar to vector.\nMemory is not guaranteed to be contiguous (unlike vector).\nAccessing elements out of bounds with d[i] is undefined behavior; use d.at(i) for safety.\nIterators may become invalid after insertions or deletions.\nDeques are useful when you need to add or remove elements from both ends frequently.\nNo capacity() or shrink_to_fit() functions, as memory management is handled differently than vector.\nUse reserve() is not available for deque.\nDeques are generally slower than vectors for pure back operations due to more complex memory management.\nSuitable for implementing both stacks and queues efficiently.\nStandard library queue and stack containers use deque as the default underlying container.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#when-to-use-deque",
    "href": "DSA Notes/C++STL/deque.html#when-to-use-deque",
    "title": "Deque",
    "section": "When to Use Deque",
    "text": "When to Use Deque\n\nWhen you need fast insertions and deletions at both the front and back.\nWhen you need random access to elements (like vector).\nWhen memory contiguity is not a strict requirement.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/deque.html#additional-points",
    "href": "DSA Notes/C++STL/deque.html#additional-points",
    "title": "Deque",
    "section": "Additional Points",
    "text": "Additional Points\n\nDeques may allocate memory in multiple chunks, so their memory is not guaranteed to be contiguous.\nThere is no direct way to reduce the memory usage of a deque (no shrink_to_fit).\nDeques do not support the reserve function.\nIf you need contiguous memory, use vector instead.\nFor multi-threaded use, consider using mutexes or thread-safe containers.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Deque"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html",
    "href": "DSA Notes/C++STL/stack.html",
    "title": "Stack",
    "section": "",
    "text": "stack&lt;T&gt; s;\nDeclares an empty stack of type T.\nstack&lt;int&gt; s2(s1);\nCopies all elements from stack s1 to s2.\nstack&lt;int&gt; s = stack&lt;int&gt;();\nInitializes an empty stack of integers.\ns.size();\nReturns the number of elements in the stack.\ns.empty();\nReturns true if the stack is empty.\ns.push(x);\nPushes element x onto the top of the stack.\ns.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\ns.pop();\nRemoves the top element (does not return it).\ns.top();\nReturns a reference to the top element.\ns.swap(s2);\nSwaps the contents of s and s2.\nThere is no direct way to access elements other than the top.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#important-points-related-to-stacks",
    "href": "DSA Notes/C++STL/stack.html#important-points-related-to-stacks",
    "title": "Stack",
    "section": "",
    "text": "stack&lt;T&gt; s;\nDeclares an empty stack of type T.\nstack&lt;int&gt; s2(s1);\nCopies all elements from stack s1 to s2.\nstack&lt;int&gt; s = stack&lt;int&gt;();\nInitializes an empty stack of integers.\ns.size();\nReturns the number of elements in the stack.\ns.empty();\nReturns true if the stack is empty.\ns.push(x);\nPushes element x onto the top of the stack.\ns.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\ns.pop();\nRemoves the top element (does not return it).\ns.top();\nReturns a reference to the top element.\ns.swap(s2);\nSwaps the contents of s and s2.\nThere is no direct way to access elements other than the top.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#example-usage",
    "href": "DSA Notes/C++STL/stack.html#example-usage",
    "title": "Stack",
    "section": "Example Usage",
    "text": "Example Usage\n\nCreating a stack of integers:\nstack&lt;int&gt; s;\nPushing elements:\ns.push(10);\ns.push(20);\ns.push(30); // Stack is now: 10 (bottom), 20, 30 (top)\nAccessing the top element:\nint x = s.top(); // x = 30\nRemoving the top element:\ns.pop(); // Stack is now: 10 (bottom), 20 (top)\nChecking if stack is empty:\nif (s.empty()) { /* stack is empty */ }\nGetting the size:\nint n = s.size();",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#notes",
    "href": "DSA Notes/C++STL/stack.html#notes",
    "title": "Stack",
    "section": "Notes",
    "text": "Notes\n\nStack is a container adapter; by default, it uses deque as the underlying container (can also use vector or list).\nFollows Last-In-First-Out (LIFO) principle.\nNo iterators are provided; you cannot traverse a stack.\nOnly the top element can be accessed or removed.\nUseful for function call management, expression evaluation, backtracking, undo operations, etc.\nTo clear a stack, repeatedly call pop() until empty.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#when-to-use-stack",
    "href": "DSA Notes/C++STL/stack.html#when-to-use-stack",
    "title": "Stack",
    "section": "When to Use Stack",
    "text": "When to Use Stack\n\nWhen you need LIFO (Last-In-First-Out) access.\nFor problems involving recursion, parsing, or backtracking.\nWhen only the most recently added element needs to be accessed or removed.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#additional-points",
    "href": "DSA Notes/C++STL/stack.html#additional-points",
    "title": "Stack",
    "section": "Additional Points",
    "text": "Additional Points\n\nYou can specify the underlying container:\nstack&lt;int, vector&lt;int&gt;&gt; s2; // Uses vector as the underlying container\nstack&lt;int, deque&lt;int&gt;&gt; s3; // Uses deque (default)\nStandard library stack does not support iteration or random access.\nIf you need to traverse or access elements, consider using deque or vector directly.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#limitations",
    "href": "DSA Notes/C++STL/stack.html#limitations",
    "title": "Stack",
    "section": "Limitations",
    "text": "Limitations\n\nCannot access or modify elements other than the top.\nNo direct way to clear all elements at once (must pop each element).\nNo iterators or random access.\nNot thread-safe by default.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#common-applications",
    "href": "DSA Notes/C++STL/stack.html#common-applications",
    "title": "Stack",
    "section": "Common Applications",
    "text": "Common Applications\n\nUndo/Redo functionality in editors.\nSyntax parsing (parentheses matching, expression evaluation).\nBacktracking algorithms (DFS, maze solving).\nFunction call stack in recursion.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/stack.html#tips",
    "href": "DSA Notes/C++STL/stack.html#tips",
    "title": "Stack",
    "section": "Tips",
    "text": "Tips\n\nIf you need to access elements other than the top, use vector or deque directly.\nFor multi-threaded use, consider using mutexes or thread-safe containers.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Stack"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html",
    "href": "DSA Notes/C++STL/set.html",
    "title": "Set",
    "section": "",
    "text": "set&lt;T&gt; s;\nDeclares an empty set of type T (elements are unique and sorted).\nset&lt;int&gt; s = {1, 2, 3};\nInitializes a set with given values.\nset&lt;int&gt; s2(s1);\nCopies all elements from set s1 to s2.\ns.insert(x);\nInserts element x into the set (if not already present).\ns.erase(x);\nRemoves element x from the set (if present).\ns.erase(it);\nRemoves the element pointed to by iterator it.\ns.erase(s.begin(), s.end());\nRemoves all elements in the given range.\ns.find(x);\nReturns an iterator to x if found, else s.end().\ns.count(x);\nReturns 1 if x is present, 0 otherwise.\ns.size();\nReturns the number of elements in the set.\ns.empty();\nReturns true if the set is empty.\ns.clear();\nRemoves all elements from the set.\ns.lower_bound(x);\nReturns iterator to the first element not less than x.\ns.upper_bound(x);\nReturns iterator to the first element greater than x.\ns.swap(s2);\nSwaps the contents of s and s2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#important-points-related-to-sets",
    "href": "DSA Notes/C++STL/set.html#important-points-related-to-sets",
    "title": "Set",
    "section": "",
    "text": "set&lt;T&gt; s;\nDeclares an empty set of type T (elements are unique and sorted).\nset&lt;int&gt; s = {1, 2, 3};\nInitializes a set with given values.\nset&lt;int&gt; s2(s1);\nCopies all elements from set s1 to s2.\ns.insert(x);\nInserts element x into the set (if not already present).\ns.erase(x);\nRemoves element x from the set (if present).\ns.erase(it);\nRemoves the element pointed to by iterator it.\ns.erase(s.begin(), s.end());\nRemoves all elements in the given range.\ns.find(x);\nReturns an iterator to x if found, else s.end().\ns.count(x);\nReturns 1 if x is present, 0 otherwise.\ns.size();\nReturns the number of elements in the set.\ns.empty();\nReturns true if the set is empty.\ns.clear();\nRemoves all elements from the set.\ns.lower_bound(x);\nReturns iterator to the first element not less than x.\ns.upper_bound(x);\nReturns iterator to the first element greater than x.\ns.swap(s2);\nSwaps the contents of s and s2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#useful-operations",
    "href": "DSA Notes/C++STL/set.html#useful-operations",
    "title": "Set",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nIterating over a set (ascending order):\nfor (auto it = s.begin(); it != s.end(); ++it) { access *it }\nRange-based for loop:\nfor (auto x : s) { access x }\nReverse iteration:\nfor (auto it = s.rbegin(); it != s.rend(); ++it) { access *it }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#notes",
    "href": "DSA Notes/C++STL/set.html#notes",
    "title": "Set",
    "section": "Notes",
    "text": "Notes\n\nset stores unique elements in sorted order (by default, ascending).\nAll operations (insert, erase, find, count, lower_bound, upper_bound) have O(log N) time complexity.\nUnderlying data structure is usually a balanced BST (like Red-Black Tree).\nElements are immutable; you cannot modify elements in-place.\nIf you need to store duplicate elements, use multiset.\nIf you need faster operations and do not require ordering, use unordered_set (average O(1) time).\nset does not provide random access (no operator[]).\nIterators remain valid except for erased elements.\nFor custom sorting, provide a comparator as a template argument.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#when-to-use-set",
    "href": "DSA Notes/C++STL/set.html#when-to-use-set",
    "title": "Set",
    "section": "When to Use Set",
    "text": "When to Use Set\n\nWhen you need to maintain a collection of unique, sorted elements.\nWhen you need fast search, insertion, and deletion (O(log N)).\nWhen order of elements matters.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/set.html#additional-points",
    "href": "DSA Notes/C++STL/set.html#additional-points",
    "title": "Set",
    "section": "Additional Points",
    "text": "Additional Points\n\nset&lt;int, greater&lt;int&gt;&gt; s; // Stores elements in descending order.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nset can be used for removing duplicates, set operations (union, intersection, difference), and maintaining ordered unique collections.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Set"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html",
    "href": "DSA Notes/C++STL/priority_queue.html",
    "title": "Priority Queue",
    "section": "",
    "text": "priority_queue&lt;T&gt; pq;\nDeclares a max-heap priority queue of type T (largest element at top).\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nDeclares a min-heap priority queue (smallest element at top).\npriority_queue&lt;T&gt; pq1(pq2);\nCopies all elements from pq2 to pq1.\npq.push(x);\nInserts element x into the priority queue.\npq.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\npq.pop();\nRemoves the top element.\npq.top();\nReturns a reference to the top element.\npq.size();\nReturns the number of elements in the priority queue.\npq.empty();\nReturns true if the priority queue is empty.\npq.swap(pq2);\nSwaps the contents of pq and pq2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#important-points-related-to-priority-queues",
    "href": "DSA Notes/C++STL/priority_queue.html#important-points-related-to-priority-queues",
    "title": "Priority Queue",
    "section": "",
    "text": "priority_queue&lt;T&gt; pq;\nDeclares a max-heap priority queue of type T (largest element at top).\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\nDeclares a min-heap priority queue (smallest element at top).\npriority_queue&lt;T&gt; pq1(pq2);\nCopies all elements from pq2 to pq1.\npq.push(x);\nInserts element x into the priority queue.\npq.emplace(args);\nConstructs element in-place at the top (faster than push for objects).\npq.pop();\nRemoves the top element.\npq.top();\nReturns a reference to the top element.\npq.size();\nReturns the number of elements in the priority queue.\npq.empty();\nReturns true if the priority queue is empty.\npq.swap(pq2);\nSwaps the contents of pq and pq2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#example-usage",
    "href": "DSA Notes/C++STL/priority_queue.html#example-usage",
    "title": "Priority Queue",
    "section": "Example Usage",
    "text": "Example Usage\n\nMax-heap (default):\npriority_queue&lt;int&gt; pq;\npq.push(10); pq.push(5); pq.push(20);\npq.top(); // 20\nMin-heap:\npriority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; pq;\npq.push(10); pq.push(5); pq.push(20);\npq.top(); // 5",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#notes",
    "href": "DSA Notes/C++STL/priority_queue.html#notes",
    "title": "Priority Queue",
    "section": "Notes",
    "text": "Notes\n\nBy default, priority_queue is a max-heap (top() returns the largest element).\nTo create a min-heap, use greater&lt;T&gt; as the third template argument.\nUnderlying container is usually vector (can also use deque).\nNo direct way to access elements other than the top.\nNo iterators or random access.\nNot thread-safe by default.\nUseful for greedy algorithms, Dijkstra‚Äôs algorithm, scheduling, etc.\nTo clear a priority queue, repeatedly call pop() until empty.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#when-to-use-priority-queue",
    "href": "DSA Notes/C++STL/priority_queue.html#when-to-use-priority-queue",
    "title": "Priority Queue",
    "section": "When to Use Priority Queue",
    "text": "When to Use Priority Queue\n\nWhen you need quick access to the largest or smallest element.\nFor problems involving ordering by priority (e.g., task scheduling, shortest path).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/priority_queue.html#additional-points",
    "href": "DSA Notes/C++STL/priority_queue.html#additional-points",
    "title": "Priority Queue",
    "section": "Additional Points",
    "text": "Additional Points\n\nCustom comparators can be used for user-defined types.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nIf you need to access or modify elements other than the top, use other containers like set or multiset.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Priority Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html",
    "href": "DSA Notes/C++STL/map.html",
    "title": "Map",
    "section": "",
    "text": "map&lt;Key, Value&gt; m;\nDeclares an empty map with keys of type Key and values of type Value.\nmap&lt;int, string&gt; m = {{1, ‚Äúone‚Äù}, {2, ‚Äútwo‚Äù}};\nInitializes a map with given key-value pairs.\nmap&lt;int, string&gt; m2(m1);\nCopies all key-value pairs from m1 to m2.\nm[key] = value;\nInserts or updates the value for the given key.\nm.at(key);\nReturns the value associated with key (throws exception if key not found).\nm.insert({key, value});\nInserts a key-value pair (does not overwrite if key exists).\nm.erase(key);\nRemoves the element with the given key.\nm.erase(it);\nRemoves the element pointed to by iterator it.\nm.erase(m.begin(), m.end());\nRemoves all elements in the given range.\nm.find(key);\nReturns an iterator to the key if found, else m.end().\nm.count(key);\nReturns 1 if key is present, 0 otherwise.\nm.size();\nReturns the number of key-value pairs in the map.\nm.empty();\nReturns true if the map is empty.\nm.clear();\nRemoves all elements from the map.\nm.lower_bound(key);\nReturns iterator to the first element not less than key.\nm.upper_bound(key);\nReturns iterator to the first element greater than key.\nm.swap(m2);\nSwaps the contents of m and m2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#important-points-related-to-maps",
    "href": "DSA Notes/C++STL/map.html#important-points-related-to-maps",
    "title": "Map",
    "section": "",
    "text": "map&lt;Key, Value&gt; m;\nDeclares an empty map with keys of type Key and values of type Value.\nmap&lt;int, string&gt; m = {{1, ‚Äúone‚Äù}, {2, ‚Äútwo‚Äù}};\nInitializes a map with given key-value pairs.\nmap&lt;int, string&gt; m2(m1);\nCopies all key-value pairs from m1 to m2.\nm[key] = value;\nInserts or updates the value for the given key.\nm.at(key);\nReturns the value associated with key (throws exception if key not found).\nm.insert({key, value});\nInserts a key-value pair (does not overwrite if key exists).\nm.erase(key);\nRemoves the element with the given key.\nm.erase(it);\nRemoves the element pointed to by iterator it.\nm.erase(m.begin(), m.end());\nRemoves all elements in the given range.\nm.find(key);\nReturns an iterator to the key if found, else m.end().\nm.count(key);\nReturns 1 if key is present, 0 otherwise.\nm.size();\nReturns the number of key-value pairs in the map.\nm.empty();\nReturns true if the map is empty.\nm.clear();\nRemoves all elements from the map.\nm.lower_bound(key);\nReturns iterator to the first element not less than key.\nm.upper_bound(key);\nReturns iterator to the first element greater than key.\nm.swap(m2);\nSwaps the contents of m and m2.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#useful-operations",
    "href": "DSA Notes/C++STL/map.html#useful-operations",
    "title": "Map",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nIterating over a map (ascending order of keys):\nfor (auto it = m.begin(); it != m.end(); ++it) { access it-&gt;first, it-&gt;second }\nRange-based for loop:\nfor (auto &p : m) { access p.first, p.second }\nReverse iteration:\nfor (auto it = m.rbegin(); it != m.rend(); ++it) { access it-&gt;first, it-&gt;second }",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#notes",
    "href": "DSA Notes/C++STL/map.html#notes",
    "title": "Map",
    "section": "Notes",
    "text": "Notes\n\nmap stores unique keys in sorted order (by default, ascending).\nAll operations (insert, erase, find, count, lower_bound, upper_bound) have O(log N) time complexity.\nUnderlying data structure is usually a balanced BST (like Red-Black Tree).\nKeys are immutable; you cannot modify keys in-place.\nIf you need to store duplicate keys, use multimap.\nIf you need faster operations and do not require ordering, use unordered_map (average O(1) time).\nmap provides random access to values via keys, but not by index.\nIterators remain valid except for erased elements.\nFor custom sorting, provide a comparator as a template argument.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#when-to-use-map",
    "href": "DSA Notes/C++STL/map.html#when-to-use-map",
    "title": "Map",
    "section": "When to Use Map",
    "text": "When to Use Map\n\nWhen you need to associate unique keys with values.\nWhen you need fast search, insertion, and deletion by key (O(log N)).\nWhen order of keys matters.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/map.html#additional-points",
    "href": "DSA Notes/C++STL/map.html#additional-points",
    "title": "Map",
    "section": "Additional Points",
    "text": "Additional Points\n\nmap&lt;int, string, greater&lt;int&gt;&gt; m; // Stores keys in descending order.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nmap is useful for frequency counting, associative arrays, and maintaining ordered key-value pairs.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Map"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html",
    "href": "DSA Notes/C++STL/list.html",
    "title": "List",
    "section": "",
    "text": "list&lt;T&gt; l;\nDeclares an empty doubly linked list of type T.\nlist&lt;int&gt; l(5, 0);\nInitializes a list of 5 integers, all set to 0.\nlist&lt;char&gt; l2(l1);\nCopies all elements from list l1 to l2.\nlist&lt;int&gt; l = {1, 2, 3};\nInitializes a list with given values.\nl.assign(n, value);\nAssigns n copies of value to the list, replacing current contents.\nl.size();\nReturns the number of elements in the list.\nl.max_size();\nReturns the maximum number of elements the list can hold.\nl.push_back(x);\nAppends element x to the end of the list.\nl.push_front(x);\nInserts element x at the beginning of the list.\nl.emplace_back(args);\nConstructs element in-place at the end.\nl.emplace_front(args);\nConstructs element in-place at the front.\nl.pop_back();\nRemoves the last element.\nl.pop_front();\nRemoves the first element.\nl.insert(it, x);\nInserts element x before iterator it.\nl.erase(it);\nRemoves the element pointed to by iterator it.\nl.erase(it1, it2);\nRemoves elements in the range [it1, it2).\nl.remove(x);\nRemoves all elements equal to x.\nl.clear();\nRemoves all elements from the list.\nl.empty();\nReturns true if the list is empty.\nl.swap(l2);\nSwaps the contents of l and l2.\nl.reverse();\nReverses the order of elements.\nl.sort();\nSorts the list in ascending order.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#important-points-related-to-lists",
    "href": "DSA Notes/C++STL/list.html#important-points-related-to-lists",
    "title": "List",
    "section": "",
    "text": "list&lt;T&gt; l;\nDeclares an empty doubly linked list of type T.\nlist&lt;int&gt; l(5, 0);\nInitializes a list of 5 integers, all set to 0.\nlist&lt;char&gt; l2(l1);\nCopies all elements from list l1 to l2.\nlist&lt;int&gt; l = {1, 2, 3};\nInitializes a list with given values.\nl.assign(n, value);\nAssigns n copies of value to the list, replacing current contents.\nl.size();\nReturns the number of elements in the list.\nl.max_size();\nReturns the maximum number of elements the list can hold.\nl.push_back(x);\nAppends element x to the end of the list.\nl.push_front(x);\nInserts element x at the beginning of the list.\nl.emplace_back(args);\nConstructs element in-place at the end.\nl.emplace_front(args);\nConstructs element in-place at the front.\nl.pop_back();\nRemoves the last element.\nl.pop_front();\nRemoves the first element.\nl.insert(it, x);\nInserts element x before iterator it.\nl.erase(it);\nRemoves the element pointed to by iterator it.\nl.erase(it1, it2);\nRemoves elements in the range [it1, it2).\nl.remove(x);\nRemoves all elements equal to x.\nl.clear();\nRemoves all elements from the list.\nl.empty();\nReturns true if the list is empty.\nl.swap(l2);\nSwaps the contents of l and l2.\nl.reverse();\nReverses the order of elements.\nl.sort();\nSorts the list in ascending order.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#useful-operations",
    "href": "DSA Notes/C++STL/list.html#useful-operations",
    "title": "List",
    "section": "Useful Operations",
    "text": "Useful Operations\n\nIterating over a list:\nfor (auto it = l.begin(); it != l.end(); ++it) { access *it }\nRange-based for loop:\nfor (auto x : l) { access x }\nSplicing (moving elements from one list to another):\nl1.splice(l1.begin(), l2); // Moves all elements from l2 to l1 at the beginning",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#notes",
    "href": "DSA Notes/C++STL/list.html#notes",
    "title": "List",
    "section": "Notes",
    "text": "Notes\n\nlist is a doubly linked list; allows fast insertion and deletion anywhere (O(1) if iterator is known).\nNo random access (no operator[] or at()).\nIterators remain valid even after insertions and deletions (except for erased elements).\nUseful when frequent insertions/deletions are needed at both ends or in the middle.\nMore memory overhead than vector or deque due to pointers.\nNot thread-safe by default.\nFor single linked list, use forward_list.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#when-to-use-list",
    "href": "DSA Notes/C++STL/list.html#when-to-use-list",
    "title": "List",
    "section": "When to Use List",
    "text": "When to Use List\n\nWhen you need frequent insertions and deletions at both ends or in the middle.\nWhen random access is not required.\nWhen stable iterators are important.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/list.html#additional-points",
    "href": "DSA Notes/C++STL/list.html#additional-points",
    "title": "List",
    "section": "Additional Points",
    "text": "Additional Points\n\nlist&lt;int, allocator&gt; l; // Custom allocator can be specified.\nFor multi-threaded use, consider using mutexes or thread-safe containers.\nUse vector or deque if you need random access or better cache performance.",
    "crumbs": [
      "Home",
      "C++ STL",
      "List"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html",
    "href": "DSA Notes/C++STL/algorithm.html",
    "title": "Algorithm",
    "section": "",
    "text": "STL algorithms are generic functions that operate on containers using iterators.\nMost algorithms are defined in the &lt;algorithm&gt; header.\nWork with all standard containers (vector, deque, list, set, map, etc.) that support iterators.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#important-points-related-to-stl-algorithms",
    "href": "DSA Notes/C++STL/algorithm.html#important-points-related-to-stl-algorithms",
    "title": "Algorithm",
    "section": "",
    "text": "STL algorithms are generic functions that operate on containers using iterators.\nMost algorithms are defined in the &lt;algorithm&gt; header.\nWork with all standard containers (vector, deque, list, set, map, etc.) that support iterators.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#commonly-used-algorithms-with-time-complexities",
    "href": "DSA Notes/C++STL/algorithm.html#commonly-used-algorithms-with-time-complexities",
    "title": "Algorithm",
    "section": "Commonly Used Algorithms (with Time Complexities)",
    "text": "Commonly Used Algorithms (with Time Complexities)\n\nsort(first, last);\nSorts the range [first, last) in ascending order. O(N log N)\nsort(first, last, comp);\nSorts with a custom comparator. O(N log N)\nstable_sort(first, last);\nSorts while preserving the relative order of equal elements. O(N log N)\npartial_sort(first, middle, last);\nSorts the range so that the smallest elements are before middle. O(N log M), M = middle-first\nnth_element(first, nth, last);\nRearranges so that the element at nth is the one that would be in that position in a sorted sequence. O(N)\nreverse(first, last);\nReverses the order of elements in the range. O(N)\nrotate(first, middle, last);\nRotates the elements in the range. O(N)\nfind(first, last, value);\nReturns iterator to the first occurrence of value, or last if not found. O(N)\nfind_if(first, last, pred);\nReturns iterator to the first element satisfying predicate. O(N)\ncount(first, last, value);\nCounts the number of elements equal to value. O(N)\ncount_if(first, last, pred);\nCounts elements satisfying predicate. O(N)\naccumulate(first, last, init);\nReturns the sum of elements in the range (requires &lt;numeric&gt;). O(N)\nmin_element(first, last);\nReturns iterator to the smallest element. O(N)\nmax_element(first, last);\nReturns iterator to the largest element. O(N)\nminmax_element(first, last);\nReturns a pair of iterators to the smallest and largest elements. O(N)\nbinary_search(first, last, value);\nReturns true if value is present (range must be sorted). O(log N)\nlower_bound(first, last, value);\nReturns iterator to the first element not less than value (range must be sorted). O(log N)\nupper_bound(first, last, value);\nReturns iterator to the first element greater than value (range must be sorted). O(log N)\nequal_range(first, last, value);\nReturns a pair of iterators for the subrange of equal elements. O(log N)\nnext_permutation(first, last);\nTransforms the range to the next lexicographically greater permutation. O(N)\nprev_permutation(first, last);\nTransforms the range to the previous permutation. O(N)\nunique(first, last);\nRemoves consecutive duplicates (returns new logical end). O(N)\nremove(first, last, value);\nMoves all elements not equal to value to the front (use with erase for containers). O(N)\nremove_if(first, last, pred);\nRemoves elements satisfying predicate. O(N)\nfill(first, last, value);\nAssigns value to all elements in the range. O(N)\ncopy(first, last, dest);\nCopies elements from [first, last) to dest. O(N)\ncopy_if(first, last, dest, pred);\nCopies elements satisfying predicate. O(N)\nall_of(first, last, pred);\nReturns true if all elements satisfy predicate. O(N)\nany_of(first, last, pred);\nReturns true if any element satisfies predicate. O(N)\nnone_of(first, last, pred);\nReturns true if no elements satisfy predicate. O(N)\nfor_each(first, last, func);\nApplies func to each element in the range. O(N)\nmerge(first1, last1, first2, last2, dest);\nMerges two sorted ranges. O(N1 + N2)\nset_union(first1, last1, first2, last2, dest);\nComputes the union of two sorted ranges. O(N1 + N2)\nset_intersection(first1, last1, first2, last2, dest);\nComputes the intersection of two sorted ranges. O(N1 + N2)\nset_difference(first1, last1, first2, last2, dest);\nComputes the difference of two sorted ranges. O(N1 + N2)\nset_symmetric_difference(first1, last1, first2, last2, dest);\nComputes the symmetric difference of two sorted ranges. O(N1 + N2)",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#example-usage",
    "href": "DSA Notes/C++STL/algorithm.html#example-usage",
    "title": "Algorithm",
    "section": "Example Usage",
    "text": "Example Usage\n\nSorting a vector:\nsort(v.begin(), v.end());\nFinding an element:\nauto it = find(v.begin(), v.end(), x);\nCounting occurrences:\nint cnt = count(v.begin(), v.end(), x);\nSumming elements:\nint sum = accumulate(v.begin(), v.end(), 0);\nBinary search:\nbool found = binary_search(v.begin(), v.end(), x);",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#notes",
    "href": "DSA Notes/C++STL/algorithm.html#notes",
    "title": "Algorithm",
    "section": "Notes",
    "text": "Notes\n\nMost algorithms work on ranges defined by iterators: [first, last).\nMany algorithms are non-modifying (find, count), while others modify the container (sort, reverse, remove).\nSome algorithms require sorted ranges (binary_search, lower_bound, upper_bound, set operations).\nUse lambda functions for custom predicates or comparators.\nAlgorithms do not change the size of containers unless used with erase (e.g., remove-erase idiom).\nFor multi-threaded use, consider thread-safe containers or synchronization.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/algorithm.html#when-to-use-stl-algorithms",
    "href": "DSA Notes/C++STL/algorithm.html#when-to-use-stl-algorithms",
    "title": "Algorithm",
    "section": "When to Use STL Algorithms",
    "text": "When to Use STL Algorithms\n\nWhen you need efficient, reusable, and well-tested operations on containers.\nTo avoid writing common routines (sorting, searching, counting, set operations, etc.) manually.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html",
    "href": "DSA Notes/C++STL/queue.html",
    "title": "Queue",
    "section": "",
    "text": "queue&lt;T&gt; q;\nDeclares an empty queue of type T.\nqueue&lt;int&gt; q2(q1);\nCopies all elements from queue q1 to q2.\nqueue&lt;int&gt; q = queue&lt;int&gt;();\nInitializes an empty queue of integers.\nq.size();\nReturns the number of elements in the queue. O(1)\nq.empty();\nReturns true if the queue is empty. O(1)\nq.push(x);\nAdds element x to the back of the queue. O(1)\nq.emplace(args);\nConstructs element in-place at the back (faster than push for objects). O(1)\nq.pop();\nRemoves the front element (does not return it). O(1)\nq.front();\nReturns a reference to the front element. O(1)\nq.back();\nReturns a reference to the last element. O(1)\nq.swap(q2);\nSwaps the contents of q and q2. O(1)\nThere is no direct way to access elements other than the front and back.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#important-points-related-to-queues",
    "href": "DSA Notes/C++STL/queue.html#important-points-related-to-queues",
    "title": "Queue",
    "section": "",
    "text": "queue&lt;T&gt; q;\nDeclares an empty queue of type T.\nqueue&lt;int&gt; q2(q1);\nCopies all elements from queue q1 to q2.\nqueue&lt;int&gt; q = queue&lt;int&gt;();\nInitializes an empty queue of integers.\nq.size();\nReturns the number of elements in the queue. O(1)\nq.empty();\nReturns true if the queue is empty. O(1)\nq.push(x);\nAdds element x to the back of the queue. O(1)\nq.emplace(args);\nConstructs element in-place at the back (faster than push for objects). O(1)\nq.pop();\nRemoves the front element (does not return it). O(1)\nq.front();\nReturns a reference to the front element. O(1)\nq.back();\nReturns a reference to the last element. O(1)\nq.swap(q2);\nSwaps the contents of q and q2. O(1)\nThere is no direct way to access elements other than the front and back.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#notes",
    "href": "DSA Notes/C++STL/queue.html#notes",
    "title": "Queue",
    "section": "Notes",
    "text": "Notes\n\nQueue is a container adapter; by default, it uses deque as the underlying container (can also use list).\nYou can specify the underlying container: queue&lt;int, list&lt;int&gt;&gt; q;\nFollows First-In-First-Out (FIFO) principle.\nNo iterators or random access; you cannot traverse or access elements by index.\nOnly the front and back elements can be accessed.\nTo clear a queue, repeatedly call pop() until empty (no clear() function).\nNot thread-safe by default; use mutexes for multi-threaded scenarios.\nAll main operations (push, pop, front, back, size, empty, swap) are O(1).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#common-applications",
    "href": "DSA Notes/C++STL/queue.html#common-applications",
    "title": "Queue",
    "section": "Common Applications",
    "text": "Common Applications\n\nBreadth-First Search (BFS) in graphs/trees.\nLevel-order traversal in trees.\nTask scheduling and buffering data streams.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#when-to-use-queue",
    "href": "DSA Notes/C++STL/queue.html#when-to-use-queue",
    "title": "Queue",
    "section": "When to Use Queue",
    "text": "When to Use Queue\n\nWhen you need FIFO (First-In-First-Out) access.\nFor problems involving level-order traversal, task scheduling, or buffering.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/queue.html#when-not-to-use-queue",
    "href": "DSA Notes/C++STL/queue.html#when-not-to-use-queue",
    "title": "Queue",
    "section": "When Not to Use Queue",
    "text": "When Not to Use Queue\n\nIf you need to access or remove elements from the middle, use deque or list.\nIf you need random access, use vector or deque.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Queue"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/string.html",
    "href": "DSA Notes/C++STL/string.html",
    "title": "String",
    "section": "",
    "text": "string s;\nDeclares an empty string.\nstring s = ‚Äúhello‚Äù;\nInitializes a string with the value ‚Äúhello‚Äù.\nstring s2(s1);\nCopies all characters from s1 to s2.\nstring s(n, ‚Äòa‚Äô);\nInitializes a string with n copies of character ‚Äòa‚Äô.",
    "crumbs": [
      "Home",
      "C++ STL",
      "String"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/string.html#important-points-related-to-strings",
    "href": "DSA Notes/C++STL/string.html#important-points-related-to-strings",
    "title": "String",
    "section": "",
    "text": "string s;\nDeclares an empty string.\nstring s = ‚Äúhello‚Äù;\nInitializes a string with the value ‚Äúhello‚Äù.\nstring s2(s1);\nCopies all characters from s1 to s2.\nstring s(n, ‚Äòa‚Äô);\nInitializes a string with n copies of character ‚Äòa‚Äô.",
    "crumbs": [
      "Home",
      "C++ STL",
      "String"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/string.html#common-member-functions",
    "href": "DSA Notes/C++STL/string.html#common-member-functions",
    "title": "String",
    "section": "Common Member Functions",
    "text": "Common Member Functions\n\ns.size() / s.length()\nReturns the number of characters in the string.\nExample:\ns.size(); // 5 for ‚Äúhello‚Äù\ns.empty()\nReturns true if the string is empty, false otherwise.\nExample:\ns.empty(); // true for ‚Äú‚Äù\ns.clear()\nRemoves all characters from the string.\nExample:\ns.clear(); // s becomes ‚Äú‚Äù\ns.push_back(‚Äòx‚Äô)\nAppends character ‚Äòx‚Äô at the end of the string.\nExample:\ns.push_back(‚Äò!‚Äô); // ‚Äúhello!‚Äù\ns.pop_back()\nRemoves the last character from the string.\nExample:\ns.pop_back(); // ‚Äúhello‚Äù -&gt; ‚Äúhell‚Äù\ns += ‚Äúabc‚Äù\nAppends ‚Äúabc‚Äù to the string.\nExample:\ns += ‚Äúabc‚Äù; // ‚Äúhelloabc‚Äù\ns.append(‚Äúdef‚Äù)\nAppends ‚Äúdef‚Äù to the string.\nExample:\ns.append(‚Äúdef‚Äù); // ‚Äúhellodef‚Äù\ns.insert(pos, ‚Äúxyz‚Äù)\nInserts ‚Äúxyz‚Äù starting at position pos.\nExample:\ns.insert(2, ‚Äúxyz‚Äù); // ‚Äúhexyzllo‚Äù\ns.erase(pos, len)\nRemoves len characters starting from position pos.\nExample:\ns.erase(1, 2); // ‚Äúhello‚Äù -&gt; ‚Äúhlo‚Äù\ns.replace(pos, len, ‚Äústr‚Äù)\nReplaces len characters from pos with ‚Äústr‚Äù.\nExample:\ns.replace(1, 2, ‚Äúxy‚Äù); // ‚Äúhello‚Äù -&gt; ‚Äúhxylo‚Äù\ns.substr(pos, len)\nReturns a substring starting at pos of length len.\nExample:\ns.substr(1, 3); // ‚Äúell‚Äù from ‚Äúhello‚Äù\ns.find(‚Äúabc‚Äù)\nReturns the index of the first occurrence of ‚Äúabc‚Äù or string::npos if not found.\nExample:\ns.find(‚Äúll‚Äù); // 2 in ‚Äúhello‚Äù\ns.rfind(‚Äúabc‚Äù)\nReturns the index of the last occurrence of ‚Äúabc‚Äù or string::npos if not found.\nExample:\ns.rfind(‚Äúl‚Äù); // 3 in ‚Äúhello‚Äù\ns.compare(s2)\nCompares s with s2 lexicographically. Returns 0 if equal, &lt;0 if s &lt; s2, &gt;0 if s &gt; s2.\nExample:\ns.compare(‚Äúhello‚Äù); // 0 if s == ‚Äúhello‚Äù\ns.at(i)\nReturns the character at index i with bounds checking (throws exception if out of range).\nExample:\ns.at(1); // ‚Äòe‚Äô in ‚Äúhello‚Äù\ns.front()\nReturns the first character.\nExample:\ns.front(); // ‚Äòh‚Äô in ‚Äúhello‚Äù\ns.back()\nReturns the last character.\nExample:\ns.back(); // ‚Äòo‚Äô in ‚Äúhello‚Äù\ns.c_str()\nReturns a C-style null-terminated string (const char).\nExample:*\nconst char* p = s.c_str();",
    "crumbs": [
      "Home",
      "C++ STL",
      "String"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/string.html#useful-operations",
    "href": "DSA Notes/C++STL/string.html#useful-operations",
    "title": "String",
    "section": "Useful Operations",
    "text": "Useful Operations\n\ngetline(cin, s);\nReads a line (including spaces) into s.\nsort(s.begin(), s.end());\nSorts the characters in the string.\nreverse(s.begin(), s.end());\nReverses the string.\nto_string(num);\nConverts a number to a string.\nExample:\nto_string(123); // ‚Äú123‚Äù\nstoi(s);\nConverts a string to an integer.\nExample:\nstoi(‚Äú456‚Äù); // 456\nstod(s);\nConverts a string to a double.\nExample:\nstod(‚Äú3.14‚Äù); // 3.14",
    "crumbs": [
      "Home",
      "C++ STL",
      "String"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/string.html#iterating-over-a-string",
    "href": "DSA Notes/C++STL/string.html#iterating-over-a-string",
    "title": "String",
    "section": "Iterating Over a String",
    "text": "Iterating Over a String\n\nUsing index:\nfor (int i = 0; i &lt; s.size(); i++) { /* access s[i] */ }\nUsing iterator:\nfor (auto it = s.begin(); it != s.end(); ++it) { /* access it / }\nUsing range-based for loop:\nfor (char c : s) { /* access c */ }",
    "crumbs": [
      "Home",
      "C++ STL",
      "String"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/string.html#notes",
    "href": "DSA Notes/C++STL/string.html#notes",
    "title": "String",
    "section": "Notes",
    "text": "Notes\n\nStrings are mutable and dynamic; they resize automatically.\nSupports relational operators: ==, &lt;, &gt;, etc.\nCan use with STL algorithms (e.g., sort, reverse).\nAccessing out-of-bounds with s[i] is undefined; use at(i) for safety.\nstring::npos is returned by search functions if not found.\nEfficient for most string operations; for heavy modifications, consider stringstream or other structures.",
    "crumbs": [
      "Home",
      "C++ STL",
      "String"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/char.html",
    "href": "DSA Notes/C++STL/char.html",
    "title": "Char and Character Functions",
    "section": "",
    "text": "The  header provides functions for character classification and conversion. These functions are useful for validating, analyzing, and transforming characters, especially when working with strings.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Char"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/char.html#overview",
    "href": "DSA Notes/C++STL/char.html#overview",
    "title": "Char and Character Functions",
    "section": "",
    "text": "The  header provides functions for character classification and conversion. These functions are useful for validating, analyzing, and transforming characters, especially when working with strings.",
    "crumbs": [
      "Home",
      "C++ STL",
      "Char"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/char.html#character-classification-functions",
    "href": "DSA Notes/C++STL/char.html#character-classification-functions",
    "title": "Char and Character Functions",
    "section": "Character Classification Functions",
    "text": "Character Classification Functions\n\nisdigit(c)\nChecks if c is a decimal digit (0-9).\nExample: isdigit(‚Äò5‚Äô) // true\nisalpha(c)\nChecks if c is an alphabetic letter (A-Z or a-z).\nExample: isalpha(‚Äòa‚Äô) // true\nisalnum(c)\nChecks if c is alphanumeric (A-Z, a-z, 0-9).\nExample: isalnum(‚Äò9‚Äô) // true\nislower(c)\nChecks if c is a lowercase letter (a-z).\nExample: islower(‚Äòa‚Äô) // true\nisupper(c)\nChecks if c is an uppercase letter (A-Z).\nExample: isupper(‚ÄòA‚Äô) // true\nisspace(c)\nChecks if c is a whitespace character (space, tab, newline, etc.).\nExample: isspace(‚Äô ‚Äô) // true\nispunct(c)\nChecks if c is a punctuation character (e.g., ., !, ?).\nExample: ispunct(‚Äò!‚Äô) // true\nisxdigit(c)\nChecks if c is a hexadecimal digit (0-9, a-f, A-F).\nExample: isxdigit(‚ÄòF‚Äô) // true\niscntrl(c)\nChecks if c is a control character (e.g., , .\nExample: iscntrl(‚Äò‚Äô) // true\nisprint(c)\nChecks if c is a printable character (including space).\nExample: isprint(‚ÄòA‚Äô) // true\nisgraph(c)\nChecks if c has a graphical representation (printable except space).\nExample: isgraph(‚ÄòA‚Äô) // true",
    "crumbs": [
      "Home",
      "C++ STL",
      "Char"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/char.html#character-conversion-functions",
    "href": "DSA Notes/C++STL/char.html#character-conversion-functions",
    "title": "Char and Character Functions",
    "section": "Character Conversion Functions",
    "text": "Character Conversion Functions\n\ntolower(c)\nConverts c to lowercase if possible.\nExample: tolower(‚ÄòA‚Äô) // ‚Äòa‚Äô\ntoupper(c)\nConverts c to uppercase if possible.\nExample: toupper(‚Äòb‚Äô) // ‚ÄòB‚Äô",
    "crumbs": [
      "Home",
      "C++ STL",
      "Char"
    ]
  },
  {
    "objectID": "DSA Notes/C++STL/char.html#notes",
    "href": "DSA Notes/C++STL/char.html#notes",
    "title": "Char and Character Functions",
    "section": "Notes",
    "text": "Notes\n\nAll functions require #include .\nThey take char (promoted to int) as input and return int (0 for false, nonzero for true).\nUseful for parsing, validation, and formatting tasks.\nFor non-ASCII or Unicode characters, consider using  and wide characters (wchar_t).",
    "crumbs": [
      "Home",
      "C++ STL",
      "Char"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/sll.html",
    "href": "DSA Notes/Linked List/sll.html",
    "title": "Singly Linked List",
    "section": "",
    "text": "üìñ Theory\nA Singly Linked List (SLL) is a fundamental linear data structure where each element, called a node, contains data and a reference to the next node in the sequence. It is widely used due to its simplicity and efficiency in dynamic memory management.\n\nNode Structure:\nEach node in a singly linked list contains:\n\nData: The value or information stored.\nNext: A pointer/reference to the next node.\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int data, Node* next = nullptr) {\n      this -&gt; data = data;\n      this -&gt; next = next;\n    }\n};\n\nKey Operations:\n\nInsertion\n\n\nAt the Beginning (Head):\n\nCreate a new node.\nPoint its next to the current head.\nUpdate head to the new node.\n\n// Insert at head\nvoid insertAtHead(Node*& head, int value) {\n    Node* newNode = new Node(value, head);\n    head = newNode;\n}\nAt the End (Tail):\n\nTraverse to the last node.\nSet its next to the new node.\n\n// Insert at tail\nvoid insertAtTail(Node*& head, int value) {\n    Node* newNode = new Node(value, nullptr);\n    if (!head) {\n        head = newNode;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next) {\n      temp = temp -&gt; next;\n    }\n    temp -&gt; next = newNode;\n}\nAfter a Given Node:\n\nFind the target node.\nInsert the new node after it.\n\n// Insert after a given node\nvoid insertAfter(Node* prev, int value) {\n    if (!prev) {\n      return;\n    }\n    Node* newNode = new Node(value, prev -&gt; next);\n    prev -&gt; next = newNode;\n}\n\n\nDeletion\n\n\nFrom the Beginning:\n\nMove head to the next node.\nDelete the old head.\n\n// Delete from head\nvoid deleteHead(Node*& head) {\n    if (!head) {\n      return;\n    }\n    Node* temp = head;\n    head = head -&gt; next;\n    delete temp;\n}\nFrom the End:\n\nTraverse to the second last node.\nSet its next to nullptr.\n\n// Delete from tail\nvoid deleteTail(Node*& head) {\n    if (!head) {\n      return;\n    }\n    if (!head -&gt; next) {\n        delete head;\n        head = nullptr;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next -&gt; next) {\n      temp = temp -&gt; next;\n    }\n    delete temp -&gt; next;\n    temp -&gt; next = nullptr;\n}\nSpecific Node:\n\nFind the node before the target.\nUpdate its next to skip the target node.\n\n// Delete node with specific value\nvoid deleteNode(Node*& head, int value) {\n    if (!head) {\n      return;\n    }\n    if (head -&gt; data == value) {\n        Node* temp = head;\n        head = head -&gt; next;\n        delete temp;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next && temp -&gt; next -&gt; data != value) {\n      temp = temp-&gt;next;\n    }\n    if (temp -&gt; next) {\n        Node* toDelete = temp -&gt; next;\n        temp -&gt; next = temp -&gt; next -&gt; next;\n        delete toDelete;\n    }\n}\n\n\nTraversal\n\n\nVisit each node from head to end, processing data as needed.\n// Traverse and print\nvoid traverse(Node* head) {\n    Node* temp = head;\n    while (temp) {\n        cout &lt;&lt; temp -&gt; data &lt;&lt; \" \";\n        temp = temp -&gt; next;\n    }\n    cout &lt;&lt; endl;\n}\n\n\nAdvantages:\n\nDynamic Size: Grows and shrinks as needed.\nEfficient Insert/Delete: Especially at the head (O(1) time).\nNo Memory Wastage: Allocates memory as required.\n\nDisadvantages:\n\nNo Random Access: Must traverse from head to access elements.\nExtra Memory: Each node stores a pointer.\nReverse Traversal Not Possible: Only one direction.\n\nApplications:\n\nImplementation of stacks and queues.\nDynamic memory allocation.\nUndo functionality in applications.\n\nVisualization:\n[1 | *] -&gt; [2 | *] -&gt; [3 | nullptr]\n\nMemory Usage:\nEach node in a singly linked list requires extra memory to store the pointer/reference to the next node, in addition to the data itself.\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nInsertion\nO(1) (at head), O(n) (at end)\nO(n)\n\n\nDeletion\nO(1) (at head), O(n) (at end)\nO(n)\n\n\nSearch\nO(n)\nO(n)\n\n\nTraversal\nO(n)\nO(n)",
    "crumbs": [
      "Home",
      "Linked List",
      "Singly Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/dll.html",
    "href": "DSA Notes/Linked List/dll.html",
    "title": "Doubly Linked List",
    "section": "",
    "text": "üìñ Theory\nA Doubly Linked List (DLL) is a linear data structure where each element, called a node, contains data and references to both the next and previous nodes in the sequence. This allows traversal in both directions and provides more flexibility compared to singly linked lists.\n\nNode Structure:\nEach node in a doubly linked list contains:\n\nData: The value or information stored.\nNext: A pointer/reference to the next node.\nPrev: A pointer/reference to the previous node.\n\nclass Node {\npublic:\n    int data;\n    Node* prev;\n    Node* next;\n\n    Node(int data, Node* prev = nullptr, Node* next = nullptr) {\n        this -&gt; data = data;\n        this -&gt; prev = prev;\n        this -&gt; next = next;\n    }\n};\n\nKey Operations:\n\nInsertion\n\n\nAt the Beginning (Head):\n\nCreate a new node.\nSet its next to the current head.\nIf head exists, set head‚Äôs prev to the new node.\nUpdate head to the new node.\n\n// Insert at head\nvoid insertAtHead(Node*& head, int value) {\n    Node* newNode = new Node(value, nullptr, head);\n    if (head) {\n        head -&gt; prev = newNode;\n    }\n    head = newNode;\n}\nAt the End (Tail):\n\nTraverse to the last node.\nSet its next to the new node.\nSet new node‚Äôs prev to the last node.\n\n// Insert at tail\nvoid insertAtTail(Node*& head, int value) {\n    Node* newNode = new Node(value);\n    if (!head) {\n        head = newNode;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next) {\n        temp = temp -&gt; next;\n    }\n    temp -&gt; next = newNode;\n    newNode -&gt; prev = temp;\n}\nAfter a Given Node:\n\nFind the target node.\nInsert the new node after it.\nUpdate the next and prev pointers accordingly.\n\n// Insert after a given node\nvoid insertAfter(Node* prevNode, int value) {\n    if (!prevNode) {\n        return;\n    }\n    Node* newNode = new Node(value, prevNode, prevNode -&gt; next);\n    if (prevNode -&gt; next) {\n        prevNode -&gt; next -&gt; prev = newNode;\n    }\n    prevNode -&gt; next = newNode;\n}\n\n\nDeletion\n\n\nFrom the Beginning:\n\nMove head to the next node.\nIf head exists, set its prev to nullptr.\nDelete the old head.\n\n// Delete from head\nvoid deleteHead(Node*& head) {\n    if (!head) {\n        return;\n    }\n    Node* temp = head;\n    head = head -&gt; next;\n    if (head) {\n        head -&gt; prev = nullptr;\n    }\n    delete temp;\n}\nFrom the End:\n\nTraverse to the last node.\nUpdate the previous node‚Äôs next to nullptr.\nDelete the last node.\n\n// Delete from tail\nvoid deleteTail(Node*& head) {\n    if (!head) {\n        return;\n    }\n    if (!head -&gt; next) {\n        delete head;\n        head = nullptr;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next) {\n        temp = temp -&gt; next;\n    }\n    temp -&gt; prev -&gt; next = nullptr;\n    delete temp;\n}\nSpecific Node:\n\nFind the node with the target value.\nUpdate the previous and next pointers to skip the node.\nDelete the node.\n\n// Delete node with specific value\nvoid deleteNode(Node*& head, int value) {\n    if (!head) {\n        return;\n    }\n    Node* temp = head;\n    while (temp && temp -&gt; data != value) {\n        temp = temp -&gt; next;\n    }\n    if (!temp) {\n        return;\n    }\n    if (temp -&gt; prev) {\n        temp -&gt; prev -&gt; next = temp -&gt; next;\n    } else {\n        head = temp -&gt; next;\n    }\n    if (temp -&gt; next) {\n        temp -&gt; next -&gt; prev = temp -&gt; prev;\n    }\n    delete temp;\n}\n\n\nTraversal\n\n\nVisit each node from head to end, processing data as needed.\n// Traverse and print\nvoid traverse(Node* head) {\n    Node* temp = head;\n    while (temp) {\n        cout &lt;&lt; temp -&gt; data &lt;&lt; \" \";\n        temp = temp -&gt; next;\n    }\n    cout &lt;&lt; endl;\n}\n\n\nAdvantages:\n\nBidirectional Traversal: Can traverse in both directions.\nEfficient Insert/Delete: Especially at both ends (O(1) time).\nNo Memory Wastage: Allocates memory as required.\n\nDisadvantages:\n\nExtra Memory: Each node stores two pointers.\nMore Complex: More pointers to manage.\nNo Random Access: Must traverse from head or tail to access elements.\n\nApplications:\n\nImplementation of advanced data structures (e.g., Deque).\nNavigation systems (forward/backward).\nUndo/Redo functionality in applications.\n\nVisualization:\nnullptr &lt;- [1 | * | *] &lt;-&gt; [2 | * | *] &lt;-&gt; [3 | * | nullptr]\n\nMemory Usage:\nEach node in a doubly linked list requires extra memory to store both the next and previous pointers, in addition to the data itself.\n\nTime and Space Complexity:\n\n\n\n\n\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nInsertion\nO(1) (at head/tail), O(n) (at position)\nO(n)\n\n\nDeletion\nO(1) (at head/tail), O(n) (at position)\nO(n)\n\n\nSearch\nO(n)\nO(n)\n\n\nTraversal\nO(n)\nO(n)",
    "crumbs": [
      "Home",
      "Linked List",
      "Doubly Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/cll.html",
    "href": "DSA Notes/Linked List/cll.html",
    "title": "Circular Linked List",
    "section": "",
    "text": "üìñ Theory\nA Circular Linked List (CLL) is a variation of linked lists in which the last node points back to the first node, forming a circle. This structure can be implemented as singly or doubly linked, but the most common is the singly circular linked list.\n\nNode Structure:\nEach node in a circular linked list contains:\n\nData: The value or information stored.\nNext: A pointer/reference to the next node.\n\nclass Node {\npublic:\n    int data;\n    Node* next;\n\n    Node(int data, Node* next = nullptr) {\n        this -&gt; data = data;\n        this -&gt; next = next;\n    }\n};\n\nKey Operations:\n\nInsertion\n\n\nAt the Beginning (Head):\n\nCreate a new node.\nIf the list is empty, point new node‚Äôs next to itself.\nOtherwise, traverse to the last node, set its next to new node, and set new node‚Äôs next to head.\nUpdate head to the new node.\n\n// Insert at head\nvoid insertAtHead(Node*& head, int value) {\n    Node* newNode = new Node(value);\n    if (!head) {\n        newNode -&gt; next = newNode;\n        head = newNode;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next != head) {\n        temp = temp -&gt; next;\n    }\n    temp -&gt; next = newNode;\n    newNode -&gt; next = head;\n    head = newNode;\n}\nAt the End (Tail):\n\nCreate a new node.\nIf the list is empty, point new node‚Äôs next to itself and set head.\nOtherwise, traverse to the last node, set its next to new node, and new node‚Äôs next to head.\n\n// Insert at tail\nvoid insertAtTail(Node*& head, int value) {\n    Node* newNode = new Node(value);\n    if (!head) {\n        newNode -&gt; next = newNode;\n        head = newNode;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next != head) {\n        temp = temp -&gt; next;\n    }\n    temp -&gt; next = newNode;\n    newNode -&gt; next = head;\n}\nAfter a Given Node:\n\nFind the target node.\nInsert the new node after it.\n\n// Insert after a given node\nvoid insertAfter(Node* prev, int value) {\n    if (!prev) {\n        return;\n    }\n    Node* newNode = new Node(value, prev -&gt; next);\n    prev -&gt; next = newNode;\n}\n\n\nDeletion\n\n\nFrom the Beginning (Head):\n\nIf the list is empty, return.\nIf only one node, delete it and set head to nullptr.\nOtherwise, traverse to the last node, set its next to head‚Äôs next, delete head, and update head.\n\n// Delete from head\nvoid deleteHead(Node*& head) {\n    if (!head) {\n        return;\n    }\n    if (head -&gt; next == head) {\n        delete head;\n        head = nullptr;\n        return;\n    }\n    Node* temp = head;\n    Node* last = head;\n    while (last -&gt; next != head) {\n        last = last -&gt; next;\n    }\n    last -&gt; next = head -&gt; next;\n    head = head -&gt; next;\n    delete temp;\n}\nFrom the End (Tail):\n\nIf the list is empty, return.\nIf only one node, delete it and set head to nullptr.\nOtherwise, traverse to the second last node, set its next to head, and delete the last node.\n\n// Delete from tail\nvoid deleteTail(Node*& head) {\n    if (!head) {\n        return;\n    }\n    if (head -&gt; next == head) {\n        delete head;\n        head = nullptr;\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next -&gt; next != head) {\n        temp = temp -&gt; next;\n    }\n    Node* toDelete = temp -&gt; next;\n    temp -&gt; next = head;\n    delete toDelete;\n}\nSpecific Node:\n\nFind the node before the target.\nUpdate its next to skip the target node.\nIf deleting head, update head.\n\n// Delete node with specific value\nvoid deleteNode(Node*& head, int value) {\n    if (!head) {\n        return;\n    }\n    if (head -&gt; data == value) {\n        deleteHead(head);\n        return;\n    }\n    Node* temp = head;\n    while (temp -&gt; next != head && temp -&gt; next -&gt; data != value) {\n        temp = temp -&gt; next;\n    }\n    if (temp -&gt; next == head) {\n        return;\n    }\n    Node* toDelete = temp -&gt; next;\n    temp -&gt; next = temp -&gt; next -&gt; next;\n    delete toDelete;\n}\n\n\nTraversal\n\n\nVisit each node starting from head, stopping when you reach head again.\n// Traverse and print\nvoid traverse(Node* head) {\n    if (!head) {\n        return;\n    }\n    Node* temp = head;\n    do {\n        cout &lt;&lt; temp -&gt; data &lt;&lt; \" \";\n        temp = temp -&gt; next;\n    } while (temp != head);\n    cout &lt;&lt; endl;\n}\n\n\nAdvantages:\n\nCircular Nature: Any node can be made the starting point.\nEfficient Insert/Delete: Especially at both ends.\nNo Nulls: No need for nullptr checks at the end.\n\nDisadvantages:\n\nComplex Traversal: Must be careful to avoid infinite loops.\nNo Random Access: Must traverse to access elements.\nExtra Memory: Each node stores a pointer.\n\nApplications:\n\nRound-robin scheduling.\nMultiplayer games (circular turn order).\nBuffer management.\n\nVisualization:\n[1 | *] -&gt; [2 | *] -&gt; [3 | *] --|\n   ^-----------------------------|\n\nMemory Usage:\nEach node in a circular linked list requires extra memory to store the pointer/reference to the next node, in addition to the data itself.\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nInsertion\nO(1) (at head/tail), O(n) (at position)\nO(n)\n\n\nDeletion\nO(1) (at head/tail), O(n) (at position)\nO(n)\n\n\nSearch\nO(n)\nO(n)\n\n\nTraversal\nO(n)\nO(n)",
    "crumbs": [
      "Home",
      "Linked List",
      "Circular Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/floyd.html",
    "href": "DSA Notes/Linked List/floyd.html",
    "title": "Floyd Algorithm",
    "section": "",
    "text": "üìñ Theory\nFloyd‚Äôs Cycle Detection Algorithm (also known as the Tortoise and Hare algorithm) is a pointer algorithm used to detect cycles in a linked list. It uses two pointers moving at different speeds to determine if a cycle exists.\n\nHow It Works:\n\nTwo pointers, slow and fast, start at the head of the linked list.\nIn each step:\n\nslow moves one node at a time (slow = slow -&gt; next)\nfast moves two nodes at a time (fast = fast -&gt; next -&gt; next`)\n\nIf there is a cycle, slow and fast will eventually meet.\nIf there is no cycle, fast will reach the end (nullptr).\n\n\nAlgorithm Implementation:\n// Floyd‚Äôs Cycle Detection Algorithm\nbool hasCycle(Node* head) {\n    Node* slow = head;\n    Node* fast = head;\n    while (fast && fast -&gt; next) {\n        slow = slow -&gt; next;\n        fast = fast -&gt; next -&gt; next;\n        if (slow == fast) {\n            return true; // Cycle detected\n        }\n    }\n    return false; // No cycle\n}\n\nFinding the Starting Node of the Cycle:\n\nAfter detecting a cycle, reset slow to head.\nMove both slow and fast one step at a time.\nThe point where they meet is the start of the cycle.\n\n// Find starting node of the cycle\nNode* detectCycleStart(Node* head) {\n    Node* slow = head;\n    Node* fast = head;\n    while (fast && fast -&gt; next) {\n        slow = slow -&gt; next;\n        fast = fast -&gt; next -&gt; next;\n        if (slow == fast) {\n            slow = head;\n            while (slow != fast) {\n                slow = slow -&gt; next;\n                fast = fast -&gt; next;\n            }\n            return slow; // Start of cycle\n        }\n    }\n    return nullptr; // No cycle\n}\n\nMathematics Behind It:\nAfter slow and fast meet inside the cycle:\n\nLet L = distance from head to start of cycle\nLet x = distance from start of cycle to meeting point\nLet C = length of the cycle\n\nAt meeting:\n\nslow has traveled L + x steps\nfast has traveled L + x + n*C steps (n is number of cycles fast completed)\n\nSince fast moves twice as fast:\n2 * (L + x) = L + x + n*C\n=&gt; L + x = n*C\n=&gt; L = n*C - x\nSo, moving L steps from meeting point brings you to the start of the cycle.\nTherefore, resetting slow to head and moving both slow and fast one step at a time, they will meet at the start of the cycle.\nVisual:\n    head\n      |\n      v\n    [A] -&gt; [B] -&gt; [C] -&gt; [D] -&gt; [E]\n                   ^             |\n                   |             v\n                  [H] &lt;- [G] &lt;- [F]\nBoth pointers meet at the start of the cycle ([C]) after moving L steps.\n\nAdvantages:\n\nEfficient: O(n) time, O(1) space.\nSimple: No need for extra data structures.\n\nApplications:\n\nDetecting cycles in linked lists.\nFinding loops in data structures.\nUseful in problems involving repeated states.\n\nVisualization:\nhead -&gt; [1] -&gt; [2] -&gt; [3] -&gt; [4] -&gt; [5]\n                  ^                 |\n                  |-----------------|\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nCycle Detection\nO(n)\nO(1)\n\n\nFind Cycle Start\nO(n)\nO(1)",
    "crumbs": [
      "Home",
      "Linked List",
      "Floyd Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/reversell.html",
    "href": "DSA Notes/Linked List/reversell.html",
    "title": "Reverse Linked List",
    "section": "",
    "text": "üìñ Theory\nReversing a linked list means changing the direction of all the next pointers so that the last node becomes the head and the head becomes the last node. This is a common operation in linked list problems.\n\nHow It Works:\n\nUse three pointers: prev, curr, and next.\nInitialize prev to nullptr and curr to head.\nIterate through the list:\n\nStore curr -&gt; next in next.\nChange curr -&gt; next to prev.\nMove prev to curr and curr to next.\n\nAt the end, prev will be the new head.\n\n\nAlgorithm Implementation:\n// Reverse a singly linked list\nNode* reverseList(Node* head) {\n    Node* prev = nullptr;\n    Node* curr = head;\n    while (curr) {\n        Node* nextNode = curr -&gt; next;\n        curr -&gt; next = prev;\n        prev = curr;\n        curr = nextNode;\n    }\n    return prev;\n}\n\nVisualization:\n    Before:\n    head -&gt; [1] -&gt; [2] -&gt; [3] -&gt; [4] -&gt; nullptr\n\n    After:\n    head -&gt; [4] -&gt; [3] -&gt; [2] -&gt; [1] -&gt; nullptr\n\nAdvantages:\n\nUseful for many linked list problems (e.g., palindrome check, k-group reversal).\nIn-place reversal with O(1) extra space.\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nReverse List\nO(n)\nO(1)",
    "crumbs": [
      "Home",
      "Linked List",
      "Reverse Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/middlell.html",
    "href": "DSA Notes/Linked List/middlell.html",
    "title": "Finding the middle of Linked List",
    "section": "",
    "text": "üìñ Theory\nFinding the middle node of a linked list is a common operation. The most efficient way is to use two pointers: slow and fast.\n\nHow It Works:\n\nInitialize two pointers, slow and fast, at the head.\nMove slow one step at a time (slow -&gt; next).\nMove fast two steps at a time (fast -&gt; next -&gt; next).\nWhen fast reaches the end (nullptr), slow will be at the middle.\n\n\nAlgorithm Implementation:\n// Find the middle node of a singly linked list\nNode* findMiddle(Node* head) {\n    Node* slow = head;\n    Node* fast = head;\n    while (fast && fast -&gt; next) {\n        slow = slow -&gt; next;\n        fast = fast -&gt; next -&gt; next;\n    }\n    return slow;\n}\n\nVisualization:\n    head -&gt; [1] -&gt; [2] -&gt; [3] -&gt; [4] -&gt; [5] -&gt; nullptr\n                           ^\n                      slow (middle)\n\n    head -&gt; [1] -&gt; [2] -&gt; [3] -&gt; [4] -&gt; nullptr\n                    ^\n                slow (middle)\n\nAdvantages:\n\nEfficient: Only one traversal needed.\nNo need to count nodes or use extra space.\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nFind Middle Node\nO(n)\nO(1)",
    "crumbs": [
      "Home",
      "Linked List",
      "Find Middle of Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/merge2sortedll.html",
    "href": "DSA Notes/Linked List/merge2sortedll.html",
    "title": "Merge 2 Sorted Linked List",
    "section": "",
    "text": "üìñ Theory\nMerging two sorted linked lists means combining them into a single sorted linked list. This is a classic problem that can be solved efficiently using pointers.\n\nHow It Works:\n\nAlways start merging from the list whose head has the smaller value.\nUse two pointers, left and right:\n\nleft starts at the head of the merged list.\nright starts at the next node of left.\n\nTraverse the merged list with left and right.\n\nIf the current node of the second list (second) fits between left and right, insert it there.\nOtherwise, move left and right forward.\n\nIf any nodes remain in the second list after the main loop, attach them to the end of the merged list.\nThe merged list is returned with all nodes in sorted order.\n\n\nAlgorithm Implementation:\n// Call merge\nNode* merge(Node* first, Node* second) {\n    if (!first) {\n        return second;\n    }\n\n    if (!second) {\n        return first;\n    }\n\n    node *left = first;\n    node *right = first -&gt; next;\n\n    while (right) {\n        if (second && second -&gt; data &gt;= left -&gt; data && second -&gt; data &lt;= right -&gt; data) {\n            left -&gt; next = second;\n            node *temp = second -&gt; next;\n            second -&gt; next = right;\n            left = second;\n            second = temp;\n        }\n        else {\n            left = right;\n            right = right -&gt; next;\n        }\n    }\n\n    while (second) {\n        left -&gt; next = second;\n        left = second;\n        second = second -&gt; next; \n    }\n\n    return first;\n\n}\n\n// Merge two sorted singly linked lists\nNode* mergeTwoLists(Node* list1, Node* list2) {\n    if (list1 -&gt; data &lt; list2 -&gt; data) {\n        return merge(list1, list2);\n    }\n    else {\n        return merge(list2, list1);\n    }\n}\n\nVisualization:\n    List 1: 1 -&gt; 3 -&gt; 5 -&gt; nullptr\n    List 2: 2 -&gt; 4 -&gt; 6 -&gt; nullptr\n\n    Merged: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 -&gt; 6 -&gt; nullptr\n\nAdvantages:\n\nEfficient: Only one traversal of both lists.\nNo extra space needed (in-place merge).\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nMerge Lists\nO(n + m)\nO(1)",
    "crumbs": [
      "Home",
      "Linked List",
      "Merge 2 Sorted Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/palindromell.html",
    "href": "DSA Notes/Linked List/palindromell.html",
    "title": "Palindrome in Linked List",
    "section": "",
    "text": "üìñ Theory\nChecking if a linked list is a palindrome means determining whether the sequence of values is the same forwards and backwards. This is a common interview problem.\n\nHow It Works:\n\nUse two pointers, slow and fast, to find the middle of the linked list.\n\nMove slow one step and fast two steps at a time.\nWhen fast reaches the end, slow will be at the middle.\n\nReverse the second half of the list starting from slow.\n\nUse prev and temp pointers to reverse links from slow to the end.\n\nCompare the first half (starting from head) and the reversed second half (starting from prev) node by node.\n\nIf all corresponding nodes match, the list is a palindrome.\n\n(Optional) Restore the list to its original order by reversing the second half again.\n\n\nAlgorithm Implementation:\n// Function to check whether the list is palindrome.\nbool isPalindrome(Node* head) {\n    if (!head || !(head -&gt; next)) {\n        return true;\n    }\n    Node* slow = head;\n    Node* fast = head;\n    while (fast) {\n        slow = slow -&gt; next;\n        fast = fast -&gt; next;\n        if (fast) {\n            fast = fast -&gt; next;\n        }\n    }\n    Node* prev = nullptr;\n    while (slow) {\n        Node* temp = slow -&gt; next;\n        slow -&gt; next = prev;\n        prev = slow;\n        slow = temp;\n    }\n    while (prev) {\n        if (head -&gt; data != prev -&gt; data) {\n            return false;\n        }\n        prev = prev -&gt; next;\n        head = head -&gt; next;\n    }\n    return true;\n}\n\nVisualization:\n    Original: 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 1 -&gt; nullptr\n    Reverse second half: 1 -&gt; 2 -&gt; 3 &lt;- 2 &lt;- 1\n    Compare: 1==1, 2==2, 3==3\n\nAdvantages:\n\nEfficient: Only one traversal to find the middle and one to compare.\nO(1) extra space (in-place reversal).\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nPalindrome Check\nO(n)\nO(1)",
    "crumbs": [
      "Home",
      "Linked List",
      "Palindrome in Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/mapsll.html",
    "href": "DSA Notes/Linked List/mapsll.html",
    "title": "Use of Maps in Linked List",
    "section": "",
    "text": "üìñ Theory\nMaps (also known as hash maps or unordered_map in C++) are useful in linked list problems for tracking occurrences of values, detecting duplicates, and more. Using a map, you can efficiently remove duplicates from a linked list by storing the count of each value.\n\nHow It Works:\n\nTraverse the linked list with a pointer.\nUse a map to store the count of each node‚Äôs data.\nIf the data is already present in the map, remove the current node.\nOtherwise, add the data to the map and move to the next node.\nContinue until the end of the list.\n\n\nAlgorithm Implementation:\n// Remove duplicates from a linked list using map\nNode* removeDuplicates(Node* head) {\n    unordered_map &lt;int, int&gt; freq;\n    Node* curr = head;\n    Node* prev = nullptr;\n    while (curr) {\n        if (freq[curr -&gt; data]) {\n            prev -&gt; next = curr -&gt; next;\n            delete curr;\n            curr = prev -&gt; next;\n        }\n        else {\n            freq[curr -&gt; data] = 1;\n            prev = curr;\n            curr = curr -&gt; next;\n        }\n    }\n    return head;\n}\n\nVisualization:\n    Input: 1 -&gt; 2 -&gt; 3 -&gt; 2 -&gt; 4 -&gt; 1 -&gt; nullptr\n    After removing duplicates: 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; nullptr\n\nAdvantages:\n\nEfficient duplicate removal in O(n) time.\nSimple and easy to implement.\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nRemove Duplicates\nO(n)\nO(n)",
    "crumbs": [
      "Home",
      "Linked List",
      "Use of Maps in Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/mergesortll.html",
    "href": "DSA Notes/Linked List/mergesortll.html",
    "title": "Merge Sort in Linked List",
    "section": "",
    "text": "üìñ Theory\nMerge Sort is an efficient, stable, divide-and-conquer sorting algorithm that can be applied to linked lists. It works by recursively dividing the list into halves, sorting each half, and then merging the sorted halves.\n\nHow It Works:\n\nFind the middle of the linked list to split it into two halves.\nRecursively sort each half using merge sort.\nMerge the two sorted halves into a single sorted list.\n\n\nAlgorithm Implementation:\n    // Find the middle node of the linked list\n    Node* findMiddle(Node* head) {\n        Node* slow = head;\n        Node* fast = head;\n\n        while (fast && fast -&gt; next) {\n            slow = slow -&gt; next;\n            fast = fast -&gt; next -&gt; next;\n        }\n\n        return slow;\n    }\n\n    // Merge two sorted linked lists\n    Node* mergeSortedLists(Node* first, Node* second) {\n        if (!first) {\n            return second;\n        }\n\n        if (!second) {\n            return first;\n        }\n\n        Node* left = first;\n        Node* right = first -&gt; next;\n\n        while (right) {\n            if (second && second -&gt; data &gt;= left -&gt; data && second -&gt; data &lt;= right -&gt; data) {\n                left -&gt; next = second;\n                Node* temp = second -&gt; next;\n                second -&gt; next = right;\n                left = second;\n                second = temp;\n            } else {\n                left = right;\n                right = right -&gt; next;\n            }\n        }\n\n        while (second) {\n            left -&gt; next = second;\n            left = second;\n            second = second -&gt; next;\n        }\n\n        return first;\n    }\n\n    // Merge two sorted lists, always starting with the smaller head\n    Node* mergeLists(Node* head1, Node* head2) {\n        if (head1 -&gt; data &gt; head2 -&gt; data) {\n            return mergeSortedLists(head2, head1);\n        }\n        else {\n            return mergeSortedLists(head1, head2);\n        }\n    }\n\n    // Recursive merge sort for linked list\n    Node* mergeSortUtil(Node* head) {\n        if (!(head -&gt; next)) {\n            return head;\n        }\n\n        Node* mid = findMiddle(head);\n        Node* head2 = mid -&gt; next;\n        mid -&gt; next = nullptr;\n\n        Node* left = mergeSortUtil(head);\n        Node* right = mergeSortUtil(head2);\n\n        return mergeLists(left, right);\n    }\n\n    // Merge Sort main function\n    Node* mergeSort(Node* head) {\n        if (!(head -&gt; next)) {\n            return head;\n        }\n\n        return mergeSortUtil(head);\n    }\n\nVisualization:\n    Original: 4 -&gt; 2 -&gt; 1 -&gt; 3 -&gt; nullptr\n    Split:    4 -&gt; 2    and    1 -&gt; 3\n    Sorted:   2 -&gt; 4    and    1 -&gt; 3\n    Merged:   1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; nullptr\n\nAdvantages:\n\nStable and efficient for linked lists.\nO(n log n) time complexity.\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nMerge Sort\nO(n log n)\nO(log n) (recursion stack)",
    "crumbs": [
      "Home",
      "Linked List",
      "Merge Sort in Linked List"
    ]
  },
  {
    "objectID": "DSA Notes/Linked List/mapaltr.html",
    "href": "DSA Notes/Linked List/mapaltr.html",
    "title": "Alternative for Maps with O(1) Space Complexity",
    "section": "",
    "text": "üìñ Theory\nIn some linked list problems, such as cloning a linked list with random pointers, maps are often used to keep track of original and cloned nodes. However, you can achieve O(1) space complexity by cleverly manipulating the list structure itself, without using extra data structures like maps.\n\nHow It Works:\n\nStep 1: Create a clone list with only data copied.\nStep 2: Insert cloned nodes in between original nodes.\nStep 3: Set the random pointers for the cloned nodes using the interleaved structure.\nStep 4: Restore the original list and extract the cloned list.\nStep 5: Return the head of the cloned list.\n\n\nAlgorithm Implementation:\n    void insertAtTail(Node*& head, Node*& tail, int value) {\n        Node* newNode = new Node(value);\n        if (!head) {\n            head = newNode;\n            tail = newNode;\n        }\n        else {\n            tail -&gt; next = newNode;\n            tail = newNode;\n        }\n    }\n\n    Node* copyList(Node* head) {\n        // Step 1: Create a Clone List\n        Node* cloneHead = nullptr;\n        Node* cloneTail = nullptr;\n        Node* temp = head;\n        while (temp != nullptr) {\n            insertAtTail(cloneHead, cloneTail, temp -&gt; data);\n            temp = temp -&gt; next;\n        }\n\n        // Step 2: Insert nodes of Clone List in between original list\n        Node* originalNode = head;\n        Node* cloneNode = cloneHead;\n        while (originalNode != nullptr && cloneNode != nullptr) {\n            Node* next = originalNode -&gt; next;\n            originalNode -&gt; next = cloneNode;\n            originalNode = next;\n\n            next = cloneNode -&gt; next;\n            cloneNode -&gt; next = originalNode;\n            cloneNode = next;\n        }\n\n        // Step 3: Random pointer copy\n        originalNode = head;\n        cloneNode = cloneHead;\n        while (originalNode != nullptr && cloneNode != nullptr) {\n            if (originalNode -&gt; random != nullptr) {\n                cloneNode -&gt; random = originalNode -&gt; random -&gt; next;\n            }\n            else {\n                cloneNode -&gt; random = nullptr;\n            }\n            cloneNode = cloneNode -&gt; next;\n            originalNode = originalNode -&gt; next;\n        }\n\n        // Step 4: Revert step 2 changes (restore original and extract clone)\n        Node* original = head;\n        Node* copy = cloneHead;\n        while (original && copy) {\n            if (original -&gt; next) {\n                original -&gt; next = original -&gt; next -&gt; next;\n            } else {\n                original -&gt; next = original -&gt; next;\n            }\n\n            if (copy -&gt; next) {\n                copy -&gt; next = copy -&gt; next -&gt; next;\n            } else {\n                copy -&gt; next = copy -&gt; next;\n            }\n\n            original = original -&gt; next;\n            copy = copy -&gt; next;\n        }\n\n        // Step 5: Return the head of the cloned list\n        return cloneHead;\n    }\n\nAdvantages:\n\nAchieves O(1) extra space (no maps or extra data structures).\nEfficient and elegant for problems involving random pointers.\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nClone Linked List\nO(n)\nO(1)",
    "crumbs": [
      "Home",
      "Linked List",
      "Alternative Approach for Maps SC O(1)"
    ]
  },
  {
    "objectID": "DSA Notes/Stack/creation.html",
    "href": "DSA Notes/Stack/creation.html",
    "title": "Creation of Stack",
    "section": "",
    "text": "üìñ Theory\nA Stack is a linear data structure that follows the Last-In-First-Out (LIFO) principle. The element inserted last is the first one to be removed.\n\nStack Operations:\n\nPush: Add an element to the top.\nPop: Remove the top element.\nTop: View the top element.\nEmpty: Check if the stack is empty.\n\n\nVisualization:\n|   30   |  &lt;-- Top\n|   20   |\n|   10   |\n---------\n\nC++ Implementation (Array):\n#include &lt;iostream&gt;\n#define MAX 100\n\nclass Stack {\n    int top;\n    int* arr;\n    int size;\npublic:\n    Stack(int size) {\n        this -&gt; size = size;\n        this -&gt; arr = new int(size);\n        this -&gt; top = -1;\n    }\n\n    void push(int x) {\n        if (top &gt;= size - 1) {\n            cout &lt;&lt; \"Stack Overflow\" &lt;&lt; endl;\n        }\n        else {\n            top++;\n            arr[top] = x;\n        }\n    }\n\n    void pop() {\n        if (top &lt; 0) {\n            cout &lt;&lt; \"Stack Underflow\" &lt;&lt; endl;\n        }\n        else {\n            top--;\n        }\n    }\n\n    int top() {\n        if (top &lt; 0) {\n          cout &lt;&lt; \"Stack is Empty\" &lt;&lt; endl;\n          return -1;\n        }\n        else {\n            return arr[top];\n        }\n    }\n\n    bool empty() {\n        if (top &lt; 0) {\n          return true;\n        }\n        else {\n          return false;\n        }\n    }\n    \n};\n\nAdvantages:\n\nSimple and easy to implement.\nEfficient for LIFO operations.\nUseful for function calls, undo mechanisms, etc.\n\n\nDisadvantages:\n\nFixed size if implemented using arrays.\nNot suitable for random access.\n\n\nApplications:\n\nExpression evaluation and conversion.\nBacktracking (e.g., maze, recursion).\nUndo mechanisms in editors.\nFunction call management.\nParanthesis problems.\n\n\nMemory Usage:\n\nArray implementation uses contiguous memory.\nEach element occupies space for data (and pointer if using linked list).\n\n\nTime and Space Complexity:\n\n\n\nOperation\nTime Complexity\nSpace Complexity\n\n\n\n\nPush\nO(1)\nO(n)\n\n\nPop\nO(1)\nO(n)\n\n\nPeek\nO(1)\nO(n)\n\n\nisEmpty\nO(1)\nO(n)",
    "crumbs": [
      "Home",
      "Stack",
      "Creation of Stack"
    ]
  },
  {
    "objectID": "DSA Notes/Stack/sortstack.html",
    "href": "DSA Notes/Stack/sortstack.html",
    "title": "Sort Stack Using Recursion (Reverse Stack)",
    "section": "",
    "text": "üìñ Theory\nSorting a stack using recursion means arranging its elements in ascending order (top to bottom) without using any extra data structures (except the call stack).\nThe idea is to recursively pop all elements, sort the smaller stack, and insert the popped element back in the correct position.\n\nC++ Implementation:\n// Helper function to insert an element in sorted order\nvoid sortedInsert(stack&lt;int&gt;& s, int x) {\n    if (s.empty() || x &gt; s.top()) {\n        s.push(x);\n        return;\n    }\n    int temp = s.top();\n    s.pop();\n    sortedInsert(s, x);\n    s.push(temp);\n}\n\n// Main function to sort the stack\nvoid sortStack(stack&lt;int&gt;& s) {\n    if (!s.empty()) {\n        int x = s.top();\n        s.pop();\n        sortStack(s);\n        sortedInsert(s, x);\n    }\n}\n\nVisualization:\nBefore Sorting (Top to Bottom):\n| 1 |\n| 5 |\n| 2 |\n| 4 |\n| 3 |\nAfter Sorting (Top to Bottom):\n| 5 |\n| 4 |\n| 3 |\n| 2 |\n| 1 |\n\nAdvantages:\n\nNo need for extra data structures (uses only recursion stack).\nSimple and elegant recursive approach.\n\n\nDisadvantages:\n\nNot efficient for large stacks (due to recursion depth).\nUses call stack, which may cause stack overflow for very large input.\n\n\nApplications:\n\nUseful for interview problems.\nWhen only stack operations are allowed and no extra space is permitted.\n\n\nSimilar Use Cases:\n\nSet top element at the bottom of the stack.\nReverse the stack.\nFind middle of the stack.\n\n\nTime and Space Complexity:\n\nTime Complexity: O(n¬≤) (each insertion may traverse the stack)\nSpace Complexity: O(n) (due to recursion stack)",
    "crumbs": [
      "Home",
      "Stack",
      "Sort/Reverse Stack"
    ]
  },
  {
    "objectID": "DSA Notes/Stack/nextsmallerelementleftright.html",
    "href": "DSA Notes/Stack/nextsmallerelementleftright.html",
    "title": "Next Smaller Element in Stack (Left & Right)",
    "section": "",
    "text": "üìñ Theory\nThe Next Smaller Element (NSE) problem finds, for each element in an array, the nearest element to its left or right that is smaller than itself.\n\nNext Smaller to Right (NSR): For each element, find the first smaller element to its right.\nNext Smaller to Left (NSL): For each element, find the first smaller element to its left.\n\nThis is efficiently solved using a stack in O(n) time.\n\nC++ Implementation:\n// Next Smaller to Right\nvector&lt;int&gt; nextSmallerRight(const vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    vector&lt;int&gt; res(n, -1);\n    stack&lt;int&gt; s;\n    for (int i = n - 1; i &gt;= 0; --i) {\n        while (!s.empty() && s.top() &gt;= arr[i]) {\n            s.pop();\n        }\n        if (!s.empty()) {\n            res[i] = s.top();\n        }\n        s.push(arr[i]);\n    }\n    return res;\n}\n\n// Next Smaller to Left\nvector&lt;int&gt; nextSmallerLeft(const vector&lt;int&gt;& arr) {\n    int n = arr.size();\n    vector&lt;int&gt; res(n, -1);\n    stack&lt;int&gt; s;\n    for (int i = 0; i &lt; n; ++i) {\n        while (!s.empty() && s.top() &gt;= arr[i]) {\n            s.pop();\n        }\n        if (!s.empty()) {\n            res[i] = s.top();\n        }\n        s.push(arr[i]);\n    }\n    return res;\n}\n\nVisualization:\nGiven array: [4, 5, 2, 10, 8]\n\nNSR: [2, 2, -1, 8, -1]\nNSL: [-1, 4, -1, 2, 2]\n\n\nAdvantages:\n\nEfficient O(n) solution using stack.\nUseful for range queries and histogram and max rectangle problems.\n\n\nDisadvantages:\n\nRequires extra space for stack and result arrays.\nOnly works for linear data structures.\n\n\nApplications:\n\nHistogram area problems.\nStock span and price drop problems.\nRange minimum queries.\nMax rectangle.\n\n\nTime and Space Complexity:\n\nTime Complexity: O(n)\nSpace Complexity: O(n)",
    "crumbs": [
      "Home",
      "Stack",
      "Next Smaller Element"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/kadane.html",
    "href": "DSA Notes/Tips and Tricks/kadane.html",
    "title": "Kadane Algorithm",
    "section": "",
    "text": "üìñ Theory\nKadane‚Äôs Algorithm is an efficient method to find the maximum sum of a contiguous subarray within a one-dimensional array of numbers (which may include negative numbers).\nIt works by iterating through the array and maintaining:\n\ncurr_max: the maximum sum of the subarray ending at the current index.\nall_max: the maximum sum seen so far among all subarrays.\nIf curr_max becomes negative, it is reset to zero (since adding a negative prefix will not help in getting a maximum sum later).\nThe algorithm can be extended to also track the actual subarray, not just the sum.\n\n\nC++ Implementation (Sum Only):\n// Returns the maximum subarray sum\nint kadane(vector&lt;int&gt;& arr) {\n    int all_max = INT_MIN; // Stores the maximum sum found so far\n    int curr_max = 0;      // Stores the current subarray sum\n\n    for (int x : arr) {\n        curr_max += x;\n        all_max = max(curr_max, all_max);\n        if (curr_max &lt; 0) {\n            curr_max = 0;\n        }\n    }\n    return all_max;\n}\n\nC++ Implementation (Sum and Subarray Indices):\n// Returns the maximum subarray sum and its indices\nint kadaneWithIndices(vector&lt;int&gt;& arr, int& start, int& end) {\n    int all_max = INT_MIN;\n    int curr_max = 0;\n    int s = 0;\n    start = end = 0;\n\n    for (int i = 0; i &lt; arr.size(); i++) {\n        curr_max += arr[i];\n\n        if (curr_max &gt; all_max) {\n            all_max = curr_max;\n            start = s;\n            end = i;\n        }\n\n        if (curr_max &lt; 0) {\n            curr_max = 0;\n            s = i + 1;\n        }\n    }\n    return all_max;\n}\n\nVariable Explanation:\n\nall_max: The maximum sum found so far during traversal.\ncurr_max: The sum of the current subarray ending at the current index.\nstart, end: Indices marking the beginning and end of the maximum sum subarray.\ns: Temporary starting index for the current candidate subarray.\n\n\nVisualization:\nGiven array: [-2, 1, -3, 4, -1, 2, 1, -5, 4]\n\n- Maximum sum subarray: [4, -1, 2, 1]\n- Maximum sum: 6\n\nAdvantages:\n\nLinear time complexity O(n).\nSimple and easy to implement.\nWorks efficiently even when negative numbers are present.\nUses constant space.\n\n\nDisadvantages:\n\nOnly gives the sum by default; modification needed to get indices or actual subarray.\nDoes not handle circular subarrays directly (requires circular Kadane‚Äôs algorithm).\n\n\nEdge Cases & Notes:\n\nIf all numbers are negative, it returns the largest (least negative) number.\nFor circular arrays, use:\nmax(kadane(arr), totalSum - kadane(invert signs of arr))\nIf the array is empty, handle appropriately to avoid undefined behavior.\n\n\nApplications:\n\nMaximum profit in stock trading (1 transaction).\nAnalyzing periods of maximum gains/losses in financial or climate data.\nImportant component in many dynamic programming problems.\nUsed in signal processing and time series analysis.\n\n\nTime and Space Complexity:\n\nTime Complexity: O(n)\nSpace Complexity: O(1)",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Kadane Algorithm"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html",
    "href": "DSA Notes/Tips and Tricks/twopointers.html",
    "title": "Two Pointers",
    "section": "",
    "text": "üìñ Theory\nTwo Pointers is a versatile technique used to solve array and string problems efficiently. It involves maintaining two indices (pointers) that move through the data structure, either from the same end or from opposite ends, to solve problems involving pairs, subarrays, partitions, or merging.\n\nOften used on sorted arrays, but can be adapted for unsorted cases.\nUseful for problems like pair sum, reversing arrays, removing duplicates, sliding window, and merging arrays.\n\n\nTypes of Two Pointers:\n\nOpposite Ends (Start & End)\nBoth pointers start at opposite ends and move towards each other.\nUse Cases:\n\nPair sum in sorted array\nPalindrome check\nReverse array\n\nBasic Template:\nint left = 0, right = arr.size() - 1;\nwhile (left &lt; right) {\n    // process pair (arr[left], arr[right])\n    if (condition) {\n        // do something\n    }\n    left++;\n    right--;\n}\nExample 1: Find Pair with Given Sum (Sorted Array)\nbool hasPairWithSum(vector&lt;int&gt;& arr, int target) {\n    int left = 0, right = arr.size() - 1;\n    while (left &lt; right) {\n        int curr_sum = arr[left] + arr[right];\n        if (curr_sum == target) {\n            return true;\n        }\n        else if (curr_sum &lt; target) {\n            left++;\n        }\n        else {\n            right--;\n        }\n    }\n    return false;\n}\nExample 2: Check Palindrome\nbool isPalindrome(string& s) {\n    int left = 0, right = s.length() - 1;\n    while (left &lt; right) {\n        if (s[left] != s[right]) return false;\n        left++;\n        right--;\n    }\n    return true;\n}\nExample 3: Reverse Array\nvoid reverseArray(vector&lt;int&gt;& arr) {\n    int left = 0, right = arr.size() - 1;\n    while (left &lt; right) {\n        swap(arr[left++], arr[right--]);\n    }\n}\n\nSame Direction (Both from Start)\nBoth pointers start from the beginning and move forward, often with one pointer leading the other.\nBasic Template:\nint left = 0;\nfor (int right = 0; right &lt; arr.size(); right++) {\n    // Expand window with right\n\n    while (/* condition not satisfied */) {\n        // Shrink from left\n        left++;\n    }\n\n    // Process or update result\n}\nUse Cases:\n\nSliding window problems\nRemoving duplicates\nLongest substring without repeating characters\n\nExample 1: Remove Duplicates from Sorted Array\nint removeDuplicates(vector&lt;int&gt;& arr) {\n    if (arr.empty()) return 0;\n    int slow = 0;\n    for (int fast = 1; fast &lt; arr.size(); fast++) {\n        if (arr[fast] != arr[slow]) {\n            slow++;\n            arr[slow] = arr[fast];\n        }\n    }\n    return slow + 1;\n}\nExample 2: Longest Substring Without Repeating Characters\nint lengthOfLongestSubstring(string s) {\n    unordered_set&lt;char&gt; seen;\n    int left = 0, max_len = 0;\n    for (int right = 0; right &lt; s.length(); right++) {\n        while (seen.count(s[right])) {\n            seen.erase(s[left++]);\n        }\n        seen.insert(s[right]);\n        max_len = max(max_len, right - left + 1);\n    }\n    return max_len;\n}\nExample 3: Minimum Size Subarray Sum ‚â• Target\nint minSubArrayLen(int target, vector&lt;int&gt;& nums) {\n    int left = 0, sum = 0, min_len = INT_MAX;\n    for (int right = 0; right &lt; nums.size(); right++) {\n        sum += nums[right];\n        while (sum &gt;= target) {\n            min_len = min(min_len, right - left + 1);\n            sum -= nums[left++];\n        }\n    }\n    return (min_len == INT_MAX) ? 0 : min_len;\n}\n\nFixed & Moving Pointer\nOne pointer is fixed while the other explores ahead to find a valid subarray or partition.\nUse Cases:\n\nPartitioning arrays\nFinding subarrays with certain properties\n\nBasic Template:\nint left = 0, sum = 0;\nfor (int right = 0; right &lt; arr.size(); right++) {\n    sum += arr[right];\n\n    while (/* condition fails */) {\n        sum -= arr[left++];\n    }\n\n    // Update result if needed\n}\nExample: Count Subarrays with Given Sum (Non-negative Numbers)\nint countSubarrays(vector&lt;int&gt;& arr, int target) {\n    int left = 0, sum = 0, count = 0;\n    for (int right = 0; right &lt; arr.size(); right++) {\n        sum += arr[right];\n        while (sum &gt; target && left &lt;= right) {\n            sum -= arr[left++];\n        }\n        if (sum == target) {\n            count++;\n        }\n    }\n    return count;\n}\n\nMultiple Arrays/Lists\nPointers traverse two different arrays/lists, often used for merging or finding intersections.\nUse Cases:\n\nMerge two sorted arrays\nIntersection of arrays\n\nBasic Template:\nint i = 0, j = 0;\nwhile (i &lt; a.size() && j &lt; b.size()) {\n    if (a[i] == b[j]) {\n        // match found\n        i++; j++;\n    }\n    else if (a[i] &lt; b[j]) i++;\n    else j++;\n}\nExample: Merge Two Sorted Arrays\nvector&lt;int&gt; mergeSortedArrays(vector&lt;int&gt;& a, vector&lt;int&gt;& b) {\n    int i = 0, j = 0;\n    vector&lt;int&gt; result;\n    while (i &lt; a.size() && j &lt; b.size()) {\n        if (a[i] &lt; b[j]) {\n            result.push_back(a[i++]);\n        }\n        else {\n            result.push_back(b[j++]);\n        }\n    }\n    while (i &lt; a.size()) {\n        result.push_back(a[i++]);\n    }\n    while (j &lt; b.size()) {\n        result.push_back(b[j++]);\n    }\n    return result;\n}\nExample: Intersection of Two Sorted Arrays\nvector&lt;int&gt; intersectSortedArrays(vector&lt;int&gt;& a, vector&lt;int&gt;& b) {\n    int i = 0, j = 0;\n    vector&lt;int&gt; result;\n    while (i &lt; a.size() && j &lt; b.size()) {\n        if (a[i] == b[j]) {\n            result.push_back(a[i]);\n            i++; j++;\n        }\n        else if (a[i] &lt; b[j]) i++;\n        else j++;\n    }\n    return result;\n}\n\n\nVariable Explanation:\n\nleft, right, slow, fast, i, j: The pointers (indices) used to traverse arrays.\nsum, count: Used for subarray sum and counting.\nresult: Stores merged or processed output.\n\n\nVisualization:\nPair Sum Example:\nGiven array: [1, 2, 3, 4, 5, 6], target sum = 9\n\nleft = 0 (arr[0] = 1), right = 5 (arr[5] = 6)\n1 + 6 = 7 &lt; 9 ‚Üí move left pointer to 1\n\nleft = 1 (arr[1] = 2), right = 5 (arr[5] = 6)\n2 + 6 = 8 &lt; 9 ‚Üí move left pointer to 2\n\nleft = 2 (arr[2] = 3), right = 5 (arr[5] = 6)\n3 + 6 = 9 == 9 ‚Üí pair found!\n\nüîÑ Sliding Window Deep Dive (Optional)\n\nFixed-size window: Used when window length is fixed (k).\nVariable-size window: Used when you expand until a condition breaks, then shrink.\n\n// Fixed-size template\nint left = 0, sum = 0;\nfor (int right = 0; right &lt; arr.size(); right++) {\n    sum += arr[right];\n    if (right - left + 1 == k) {\n        // process window [left, right]\n        sum -= arr[left++];\n    }\n}\n\n// Variable-size template\nint left = 0, sum = 0;\nfor (int right = 0; right &lt; arr.size(); right++) {\n    sum += arr[right];\n    while (sum &gt; target) {\n        sum -= arr[left++];\n    }\n    // check or update result\n}\n\nAdvantages:\n\nLinear time complexity O(n) for many problems.\nSpace efficient (often O(1) extra space).\nSimple and intuitive for many array/string problems.\n\n\nDisadvantages:\n\nUsually requires the array to be sorted (for pair sum problems).\nNot always applicable to unsorted data without modifications.\n\n\nEdge Cases & Notes:\n\nFor unsorted arrays, may need to sort first (O(n log n)).\nCan be adapted for strings, linked lists, and sliding window problems.\nWatch for overlapping pointers and off-by-one errors.\n\n\nCommon Mistakes to Avoid:\n\nForgetting to update left or right.\nInfinite loops from incorrect loop conditions.\nOff-by-one errors in calculating window size.\nFailing to reset variables like sum, count, set, or map.\nIgnoring edge cases like empty arrays or all negatives.\nAssuming the array is sorted when it‚Äôs not.\n\n\nApplications:\n\nPair sum and triplet sum problems.\nRemoving duplicates from sorted arrays.\nPartitioning arrays.\nReversing arrays or strings.\nSliding window problems.\nMerging sorted arrays.\nIntersection of arrays.\n\n\nTime and Space Complexity:\n\nTime Complexity: O(n) (for most problems)\nSpace Complexity: O(1) (except for merging, which may use O(n))",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#types-of-two-pointers",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#types-of-two-pointers",
    "title": "Two Pointers",
    "section": "Types of Two Pointers",
    "text": "Types of Two Pointers\n\n1. Opposite Ends (Start & End)\nBoth pointers start at opposite ends and move towards each other.\nUse Cases:\n- Pair sum in sorted array\n- Palindrome check\n- Reverse array\nExample: Find Pair with Given Sum (Sorted Array)\n// Returns true if there exists a pair with the given sum\nbool hasPairWithSum(vector&lt;int&gt;& arr, int target) {\n    int left = 0, right = arr.size() - 1;\n    while (left &lt; right) {\n        int curr_sum = arr[left] + arr[right];\n        if (curr_sum == target) return true;\n        else if (curr_sum &lt; target) left++;\n        else right--;\n    }\n    return false;\n}\n\n\n\n2. Same Direction (Both from Start)\nBoth pointers start from the beginning and move forward, often with one pointer leading the other.\nUse Cases:\n- Sliding window problems\n- Removing duplicates\n- Longest substring without repeating characters\nExample: Remove Duplicates from Sorted Array\n// Removes duplicates in-place and returns new length\nint removeDuplicates(vector&lt;int&gt;& arr) {\n    if (arr.empty()) return 0;\n    int slow = 0;\n    for (int fast = 1; fast &lt; arr.size(); fast++) {\n        if (arr[fast] != arr[slow]) {\n            slow++;\n            arr[slow] = arr[fast];\n        }\n    }\n    return slow + 1;\n}\n\n\n\n3. Fixed & Moving Pointer\nOne pointer is fixed while the other explores ahead to find a valid subarray or partition.\nUse Cases:\n- Partitioning arrays\n- Finding subarrays with certain properties\nExample: Find Subarrays with Given Sum\n// Counts subarrays with sum equal to target (non-negative numbers)\nint countSubarrays(vector&lt;int&gt;& arr, int target) {\n    int left = 0, sum = 0, count = 0;\n    for (int right = 0; right &lt; arr.size(); right++) {\n        sum += arr[right];\n        while (sum &gt; target && left &lt;= right) {\n            sum -= arr[left++];\n        }\n        if (sum == target) count++;\n    }\n    return count;\n}\n\n\n\n4. Multiple Arrays/Lists\nPointers traverse two different arrays/lists, often used for merging or finding intersections.\nUse Cases:\n- Merge two sorted arrays\n- Intersection of arrays\nExample: Merge Two Sorted Arrays\n// Merges two sorted arrays into one sorted array\nvector&lt;int&gt; mergeSortedArrays(vector&lt;int&gt;& a, vector&lt;int&gt;& b) {\n    int i = 0, j = 0;\n    vector&lt;int&gt; result;\n    while (i &lt; a.size() && j &lt; b.size()) {\n        if (a[i] &lt; b[j]) result.push_back(a[i++]);\n        else result.push_back(b[j++]);\n    }\n    while (i &lt; a.size()) result.push_back(a[i++]);\n    while (j &lt; b.size()) result.push_back(b[j++]);\n    return result;\n}",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#variable-explanation",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#variable-explanation",
    "title": "Two Pointers",
    "section": "Variable Explanation",
    "text": "Variable Explanation\n\nleft, right, slow, fast, i, j: The pointers (indices) used to traverse arrays.\nsum, count: Used for subarray sum and counting.\nresult: Stores merged or processed output.",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#visualization",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#visualization",
    "title": "Two Pointers",
    "section": "Visualization",
    "text": "Visualization\nPair Sum Example:\nGiven array: [1, 2, 3, 4, 5, 6], target sum = 9\n\nleft = 0 (arr[0] = 1), right = 5 (arr[5] = 6)\n1 + 6 = 7 &lt; 9 ‚Üí move left pointer to 1\n\nleft = 1 (arr[1] = 2), right = 5 (arr[5] = 6)\n2 + 6 = 8 &lt; 9 ‚Üí move left pointer to 2\n\nleft = 2 (arr[2] = 3), right = 5 (arr[5] = 6)\n3 + 6 = 9 == 9 ‚Üí pair found!",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#advantages",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#advantages",
    "title": "Two Pointers",
    "section": "Advantages",
    "text": "Advantages\n\nLinear time complexity O(n) for many problems.\nSpace efficient (often O(1) extra space).\nSimple and intuitive for many array/string problems.",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#disadvantages",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#disadvantages",
    "title": "Two Pointers",
    "section": "Disadvantages",
    "text": "Disadvantages\n\nUsually requires the array to be sorted (for pair sum problems).\nNot always applicable to unsorted data without modifications.",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#edge-cases-notes",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#edge-cases-notes",
    "title": "Two Pointers",
    "section": "Edge Cases & Notes",
    "text": "Edge Cases & Notes\n\nFor unsorted arrays, may need to sort first (O(n log n)).\nCan be adapted for strings, linked lists, and sliding window problems.\nWatch for overlapping pointers and off-by-one errors.",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#applications",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#applications",
    "title": "Two Pointers",
    "section": "Applications",
    "text": "Applications\n\nPair sum and triplet sum problems.\nRemoving duplicates from sorted arrays.\nPartitioning arrays.\nReversing arrays or strings.\nSliding window problems.\nMerging sorted arrays.\nIntersection of arrays.",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  },
  {
    "objectID": "DSA Notes/Tips and Tricks/twopointers.html#time-and-space-complexity",
    "href": "DSA Notes/Tips and Tricks/twopointers.html#time-and-space-complexity",
    "title": "Two Pointers",
    "section": "Time and Space Complexity",
    "text": "Time and Space Complexity\n\nTime Complexity: O(n) (for most problems)\nSpace Complexity: O(1) (except for merging, which may use O(n))",
    "crumbs": [
      "Home",
      "Tips and Tricks",
      "Two Pointers"
    ]
  }
]